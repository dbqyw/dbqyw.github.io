<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>qinyiwen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="qinyiwen">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="qinyiwen">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="qinyiwen" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">qinyiwen</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Exercise 7 - VLC Media Player" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/01/Exercise%207%20-%20VLC%20Media%20Player/" class="article-date">
  <time class="dt-published" datetime="2023-08-01T15:21:53.000Z" itemprop="datePublished">2023-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/08/01/Exercise%207%20-%20VLC%20Media%20Player/">Exercise 7 - VLC Media Player</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Exercise-7-VLC-Media-Player"><a href="#Exercise-7-VLC-Media-Player" class="headerlink" title="Exercise 7 - VLC Media Player"></a>Exercise 7 - VLC Media Player</h3><h4 id="一、实验背景"><a href="#一、实验背景" class="headerlink" title="一、实验背景"></a>一、实验背景</h4><p><strong>CVE-2019-14776</strong>是一个越界读取漏洞，可以通过精心制作的WMV&#x2F;ASF (Windows Media Video)文件触发。越界读取是当程序读取数据超过预期缓冲区的末尾或开始之前时发生的漏洞。因此，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息。</p>
<p>越界读取漏洞（<a target="_blank" rel="noopener" href="https://cwe.mitre.org/data/definitions/125.html%EF%BC%89">https://cwe.mitre.org/data/definitions/125.html）</a></p>
<p><strong>部分仪器仪表</strong></p>
<p>使用进化覆盖引导的模糊器的优点之一是，它能够自己找到新的执行路径。然而，这通常也是一个缺点。当我们面对具有高度模块化架构的软件(如VLC媒体播放器)时，每个模块执行特定的任务。</p>
<p>那么，假设我们给监控器提供了一个有效的MKV文件。但是在对输入文件进行了几次修改之后，“magic bytes”文件发生了变化，现在我们的程序将输入文件视为AVI文件。因此，这个“变异的MKV文件”现在由AVI Demux处理。一段时间后，文件魔术字节再次改变，现在文件被视为MPEG文件。在这两种情况下，这个新修改的文件增加代码覆盖率的可能性都很低，因为这个新文件没有任何有效的语法结构。</p>
<p>简而言之，如果我们不对代码覆盖率施加限制，模糊测试者很容易选择错误的路径，从而使模糊测试过程效率降低。</p>
<p>为了解决这个问题，afl++包含了一个部分插装特性，它允许指定应该使用或不使用插装来编译哪些函数&#x2F;文件。这有助于模糊器专注于程序的重要部分，通过执行无趣的代码路径来避免不必要的噪声和干扰。</p>
<p>为了使用它，我们在编译时设置环境AFL_LLVM_ALLOWLIST变量。这个环境变量必须指向一个包含所有应该检测的函数&#x2F;文件名的文件。</p>
<p>afl++部分仪器（<a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.instrument_list.md%EF%BC%89">https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.instrument_list.md）</a></p>
<h4 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h4><p>模糊<strong>VLC</strong>媒体播放器。目标是在VLC 3.0.7.1中找到<a target="_blank" rel="noopener" href="https://nvd.nist.gov/vuln/detail/CVE-2019-14776"><strong>CVE-2019-14776</strong></a>的崩溃&#x2F;PoC</p>
<h4 id="三、实验环境："><a href="#三、实验环境：" class="headerlink" title="三、实验环境："></a>三、实验环境：</h4><p>win10，VMware，Ubuntu 20.04.2 LTS（虚拟机用户名密码均为fuzz）</p>
<h4 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h4><h5 id="1、下载并构建目标"><a href="#1、下载并构建目标" class="headerlink" title="1、下载并构建目标"></a>1、下载并构建目标</h5><p>得到模糊目标，为要模糊化的项目创建一个新目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir fuzzing_vlc &amp;&amp; cd fuzzing_vlc</span><br></pre></td></tr></table></figure>

<p>下载并解压vlc-3.0.7.1.tar.xz</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.videolan.org/pub/videolan/vlc/3.0.7.1/vlc-3.0.7.1.tar.xz</span><br><span class="line">tar -xvf vlc-3.0.7.1.tar.xz &amp;&amp; cd vlc-3.0.7.1/</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/3202c8c2-020e-43e7-acdd-6b1fc2e1b5d3" alt="image"></p>
<p>发现下载链接连接失败，用管理员身份下载，解决问题</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/cd3e5bab-c56e-461b-bf35-3a206fe5ca17" alt="image"></p>
<h5 id="2、构建VCL"><a href="#2、构建VCL" class="headerlink" title="2、构建VCL"></a>2、构建VCL</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=&quot;$HOME/fuzzing_vlc/vlc-3.0.7.1/install&quot; --disable-a52 --disable-lua --disable-qt</span><br><span class="line">make -j$(nproc)</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/8b5ea12b-8a45-4fc8-98c8-055762f3074e" alt="image"></p>
<p>报错</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/0abd4ced-6a37-410c-abbd-67d841f13c68" alt="image"></p>
<p>解决方案</p>
<p>安装一些必要的依赖库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libxcb-composite0-dev libxcb-glx0-dev libxcb-dri2-0-dev libxcb-xf86dri0-dev libxcb-xinerama0-dev libxcb-render-util0-dev</span><br><span class="line">apt-get install libxcb-xv0-dev</span><br><span class="line">apt-get install libxcb-randr0-dev</span><br><span class="line">apt-get install libasound2-dev</span><br><span class="line">apt-get install libvlc-dev</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/0982fa2d-3152-4151-8ada-79eb2f254b18" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/34af0e30-08f8-44bc-9349-8f8e6ce30010" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/96b4bcc3-158c-4b6e-ba44-2ababb31bfad" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/9f19e66f-ad36-4128-9c95-612efba4dd7e" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/73c23d48-c702-439c-97f2-8662bad8ad61" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/e218173c-f154-40cb-aca9-f3963f021a79" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/d737430f-45fd-4c50-bde3-90fc21f656b8" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/b0692ec5-08db-4708-8dd7-de887b5a130e" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/440e516b-b84e-46c4-811b-a04766c51586" alt="image"></p>
<p>安装完依赖库后，重新运行.config，成功构建VCL</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/fd9c3400-3ea2-4430-baa4-e1e3748ca356" alt="image"></p>
<p>测试工作是否正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/vlc-static --help</span><br></pre></td></tr></table></figure>

<p>如看到以下页面，说明工作正确</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/2f1b8946-18bc-46d3-a7ef-e80a8c48401c" alt="image"></p>
<h5 id="3、种子语料库创建"><a href="#3、种子语料库创建" class="headerlink" title="3、种子语料库创建"></a>3、种子语料库创建</h5><p>可以在<a target="_blank" rel="noopener" href="https://samples.ffmpeg.org/">ffmpeg示例库</a>中找到大量视频示例。</p>
<p>建议挑选一些样本，然后使用视频编辑器将视频文件缩小到尽可能小的大小。</p>
<p>以下是一些开源视频编辑器的例子:</p>
<p>——(OpenShot) (<a target="_blank" rel="noopener" href="https://www.openshot.org/">https://www.openshot.org/</a>)</p>
<p>——(Shotcut) (<a target="_blank" rel="noopener" href="https://shotcut.org/">https://shotcut.org/</a>)</p>
<p>或者复制<a href="./InputCorpus/short2.wmv">short2.wmv</a>和<a href="./InputCorpus/veryshort.wmv">veryshort.wmv</a>文件到AFL输入文件夹</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/723e0f2a-62c7-4376-b9e2-c3e281cf0240" alt="image"></p>
<h5 id="4、fuzzing线束"><a href="#4、fuzzing线束" class="headerlink" title="4、fuzzing线束"></a>4、fuzzing线束</h5><p>如果尝试直接模糊“vlc-static”二进制文件，将看到AFL每秒只执行几次。这是因为VLC启动非常耗时。这就是为什么为模糊测试VLC创建一个自定义模糊测试线束。</p>
<p>修改’ ‘ .&#x2F;test&#x2F;vlc-demux-run.c ‘ ‘文件以包含模糊测试工具。通过这种方式，只需执行以下操作即可编译该harness:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd test</span><br><span class="line">make vlc-demux-run -j$(nproc) LDFLAGS=&quot;-fsanitize=address&quot;</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/8c630391-698e-495d-ae8b-520a844d8999" alt="image"></p>
<p>由于该错误存在于ASF解模中，所以调用<strong>vlc_demux_process_memory</strong>函数。这个函数尝试删除先前存储在内存中的数据缓冲区。可以在这里找到代码修改(.&#x2F;fuzzing_harness.patch)</p>
<h5 id="5、部分仪器化"><a href="#5、部分仪器化" class="headerlink" title="5、部分仪器化"></a>5、部分仪器化</h5><p>一开始，尝试只包括ASF拆模所涉及的文件名。不幸的是，这种方法不起作用。似乎文件名匹配是<a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/issues/1018#issuecomment-879045408">并不总是可能的</a>，所以选择了一个混合的方法，包括函数匹配和文件名匹配</p>
<p>可以下载部分检测文件(.&#x2F;Partial_instrumentation)</p>
<h5 id="6、小改动"><a href="#6、小改动" class="headerlink" title="6、小改动"></a>6、小改动</h5><p>为了加快ASF模糊测试的速度，建议将这个补丁应用到<strong>modules&#x2F;demux&#x2F;libasf.c</strong> (目前没有更多的线索;)):[speeup .patch](.&#x2F; speeup .patch)</p>
<h5 id="7、fuzzing"><a href="#7、fuzzing" class="headerlink" title="7、fuzzing"></a>7、fuzzing</h5><p>使用<strong>afl-clang-fast</strong>作为编译器并启用ASAN构建VLC的时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC=&quot;afl-clang-fast&quot; CXX=&quot;afl-clang-fast++&quot; ./configure --prefix=&quot;$HOME/fuzzing_vlc/vlc-3.0.7.1/install&quot; --disable-a52 --disable-lua --disable-qt --with-sanitizer=address</span><br><span class="line">AFL_LLVM_ALLOWLIST=$HOME/fuzzing_vlc/vlc-3.0.7.1/Partial_instrumentation make -j$(nproc) LDFLAGS=&quot;-fsanitize=address&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/75b90691-fdd0-4623-959a-509166ccf415" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/8805c9e9-c6df-49bc-95e8-4100fa926990" alt="image"></p>
<p>构建模糊控制装置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd test</span><br><span class="line">make vlc-demux-run -j$(nproc) LDFLAGS=&quot;-fsanitize=address&quot;</span><br><span class="line">cd ..  </span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7375cb28-c429-4fcb-8f73-86377f36c6c9" alt="image"></p>
<p>运行fuzzer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -t 100 -m none -i &#x27;./afl_in&#x27; -o &#x27;./afl_out&#x27; -x asf_dictionary.dict -D -M master -- ./test/vlc-demux-run @@    </span><br></pre></td></tr></table></figure>

<p>注意事项：超时参数严重依赖于计算机，需要调整这个值</p>
<p>过一段时间，可以看到多个崩溃</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/378225ea-06c2-4351-a815-85f48b7a257c" alt="image"></p>
<p><img src="C:\Users\15646\AppData\Roaming\Typora\typora-user-images\image-20230802153658669.png" alt="image-20230802153658669"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/63ee9621-c317-45f4-b390-4628ce9960a5" alt="Image1"></p>
<h5 id="8、Triage"><a href="#8、Triage" class="headerlink" title="8、Triage"></a>8、Triage</h5><p>ASan跟踪可能看起来像</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/21e1a6e2-dd80-41fb-8660-8646c6502027" alt="image3"></p>
<h5 id="9、修复问题"><a href="#9、修复问题" class="headerlink" title="9、修复问题"></a>9、修复问题</h5><p>修复这两个bug后重建目标，并检查PoC不再使程序崩溃</p>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>通过这个实验，我了解了<strong>CVE-2019-14776</strong>漏洞，学会如何使用部分仪器只对程序的相关部分进行仪器检测，如何编写模糊测试工具来更有效地测试大型应用程序</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/08/01/Exercise%207%20-%20VLC%20Media%20Player/" data-id="clktgz1j70000p8vff6fg5aw8" data-title="Exercise 7 - VLC Media Player" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Exercise 6 - GIMP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/31/Exercise%206%20-%20GIMP/" class="article-date">
  <time class="dt-published" datetime="2023-07-31T15:09:51.000Z" itemprop="datePublished">2023-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/31/Exercise%206%20-%20GIMP/">Exercise 6 - GIMP</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Exercise-6-GIMP"><a href="#Exercise-6-GIMP" class="headerlink" title="Exercise 6 - GIMP"></a>Exercise 6 - GIMP</h3><h4 id="一、实验背景"><a href="#一、实验背景" class="headerlink" title="一、实验背景"></a>一、实验背景</h4><p><strong>CVE-2016-4994</strong>是一个可以通过精心制作的XCF文件触发的Use-After-Free漏洞。当程序在释放指针后继续使用指针时，会发生释放错误。这可能会产生许多不良后果，从破坏有效数据到执行任意代码。</p>
<p>Use-After-Free漏洞（<a target="_blank" rel="noopener" href="https://cwe.mitre.org/data/definitions/416.html%EF%BC%89">https://cwe.mitre.org/data/definitions/416.html）</a></p>
<p><strong>持久模式</strong></p>
<p>AFL持久模式基于进程内fuzzers: fuzzers利用单个进程，将代码注入目标进程并更改内存中的输入值。full -fuzz支持一种工作模式，它结合了进程内模糊测试的优点和更传统的多进程工具的健壮性:持久模式。在持久模式下，afl++在单个分叉进程中对目标进行多次模糊处理，而不是为每次执行模糊处理都创建一个新进程。该模式可将模糊测试速度提高20倍。</p>
<p>目标的基本结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Program initialization</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (__AFL_LOOP(<span class="number">10000</span>)) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Read input data. */</span></span><br><span class="line">  <span class="comment">/* Call library code to be fuzzed. */</span></span><br><span class="line">  <span class="comment">/* Reset state. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//End of fuzzing</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>afl++持久模式（<a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md%EF%BC%89">https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md）</a></p>
<h4 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h4><p>模糊<strong>GIMP</strong>图像编辑器。目标是在GIMP 2.8.16中找到<a target="_blank" rel="noopener" href="https://www.cvedetails.com/cve/CVE-2016-4994/"><strong>CVE-2016-4994</strong></a>的崩溃&#x2F;PoC</p>
<h4 id="三、实验环境："><a href="#三、实验环境：" class="headerlink" title="三、实验环境："></a>三、实验环境：</h4><p>win10，VMware，Ubuntu 20.04.2 LTS（虚拟机用户名密码均为fuzz）</p>
<h4 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h4><h5 id="1、下载并构建目标"><a href="#1、下载并构建目标" class="headerlink" title="1、下载并构建目标"></a>1、下载并构建目标</h5><p>得到模糊目标，为要模糊化的项目创建一个新目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir Fuzzing_gimp &amp;&amp; cd Fuzzing_gimp</span><br></pre></td></tr></table></figure>

<p>安装依赖项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install build-essential libatk1.0-dev libfontconfig1-dev libcairo2-dev libgudev-1.0-0 libdbus-1-dev libdbus-glib-1-dev libexif-dev libxfixes-dev libgtk2.0-dev python2.7-dev libpango1.0-dev libglib2.0-dev zlib1g-dev intltool libbabl-dev</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/217f1d72-3f11-43e0-9349-19b3054e39eb" alt="image"></p>
<p>下载并构建GEGL 0.2(通用图形库)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.gimp.org/pub/gegl/0.2/gegl-0.2.0.tar.bz2</span><br><span class="line">tar xvf gegl-0.2.0.tar.bz2 &amp;&amp; cd gegl-0.2.0</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7710b53d-1f28-46cf-a759-2803dea33a20" alt="image"></p>
<p>对源代码做两个小的修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/CODEC_CAP_TRUNCATED/AV_CODEC_CAP_TRUNCATED/g&#x27; ./operations/external/ff-load.c</span><br><span class="line">sed -i &#x27;s/CODEC_FLAG_TRUNCATED/AV_CODEC_FLAG_TRUNCATED/g&#x27; ./operations/external/ff-load.c</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/61453004-8215-4515-8959-64901b51e1b1" alt="image"></p>
<p>构建并安装Gegl-0.2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-debug --disable-glibtest  --without-vala --without-cairo --without-pango --without-pangocairo --without-gdk-pixbuf --without-lensfun --without-libjpeg --without-libpng --without-librsvg --without-openexr --without-sdl --without-libopenraw --without-jasper --without-graphviz --without-lua --without-libavformat --without-libv4l --without-libspiro --without-exiv2 --without-umfpack</span><br><span class="line">make -j$(nproc)</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/479ad11c-4518-4158-bd26-53fec0919074" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/79ecb2c0-d77b-4d0e-8ce4-d28785d0281d" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/5b931164-daf3-4b97-99c2-3156517b3316" alt="image"></p>
<p>如果在测试阶段看到一些错误消息，不要担心</p>
<p>下载并解压GIMP 2.8.16</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">wget https://mirror.klaus-uwe.me/gimp/pub/gimp/v2.8/gimp-2.8.16.tar.bz2</span><br><span class="line">tar xvf gimp-2.8.16.tar.bz2 &amp;&amp; cd gimp-2.8.16/</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/68a0cc96-6440-4ca5-9810-e46f600528a0" alt="image"></p>
<p>使用<strong>afl-clang-lto</strong>作为编译器构建GIMP的时间(可能需要一些时间)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CC=afl-clang-lto CXX=afl-clang-lto++ PKG_CONFIG_PATH=$PKG_CONFIG_PATH:$HOME/Fuzzing_gimp/gegl-0.2.0/ CFLAGS=&quot;-fsanitize=address&quot; CXXFLAGS=&quot;-fsanitize=address&quot; LDFLAGS=&quot;-fsanitize=address&quot; ./configure --disable-gtktest --disable-glibtest --disable-alsatest --disable-nls --without-libtiff --without-libjpeg --without-bzip2 --without-gs --without-libpng --without-libmng --without-libexif --without-aa --without-libxpm --without-webkit --without-librsvg --without-print --without-poppler --without-cairo-pdf --without-gvfs --without-libcurl --without-wmf --without-libjasper --without-alsa --without-gudev --disable-python --enable-gimp-console --without-mac-twain --without-script-fu --without-gudev --without-dbus --disable-mp --without-linux-input --without-xvfb-run --with-gif-compression=none --without-xmc --with-shm=none --enable-debug  --prefix=&quot;$HOME/Fuzzing_gimp/gimp-2.8.16/install&quot;</span><br><span class="line">make -j$(nproc)</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7754716a-60de-46b1-af94-c913d0b9b755" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/c8444d9b-6d99-493d-ad19-6e122e7df54d" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/e9dd7b26-9d03-4858-a63b-f8d00eb9d7c0" alt="image"></p>
<h5 id="2、持久模式"><a href="#2、持久模式" class="headerlink" title="2、持久模式"></a>2、持久模式</h5><p>有两种非常简单的方法:</p>
<p>第一个是修改’ ‘ app.c ‘ ‘文件，并将AFL_LOOP宏包含到for循环中</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/9e9138ee-cef7-47f5-8142-8052da800b8f" alt="image"></p>
<p>第二种方法是在’ ‘ xcf_load_invoker ‘ ‘函数中插入AFL_LOOP宏</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/db175fdb-b8f9-471d-aaf2-528ecf976409" alt="Image1"></p>
<p>虽然第一个允许我们针对不同的输入格式，第二个更快，我们将有更多的机会抓住错误。</p>
<p>下载第二个补丁<a href="./persistent.patch">在这里</a></p>
<h5 id="2、种子语料库创建"><a href="#2、种子语料库创建" class="headerlink" title="2、种子语料库创建"></a>2、种子语料库创建</h5><p>建议创建多个GIMP项目并保存它们以获得多个.xcf示例，或者，可以将<a href="./SampleInput.xcf">SampleInput.xcf</a>文件复制到您的AFL输入文件夹中</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/b1dfc8ce-710f-4388-8d79-4f2c7bde4348" alt="image"></p>
<h5 id="3、fuzzing"><a href="#3、fuzzing" class="headerlink" title="3、fuzzing"></a>3、fuzzing</h5><p>由于该漏洞影响GIMP核心，可以通过删除不需要的插件来节省一些启动时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm ./install/lib/gimp/2.0/plug-ins/*</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/668873ab-07d5-4def-8f4a-36718cb804f0" alt="image"></p>
<p>使用以下命令运行fuzzer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASAN_OPTIONS=detect_leaks=0,abort_on_error=1,symbolize=0 afl-fuzz -i &#x27;./afl_in&#x27; -o &#x27;./afl_out&#x27; -D -t 100 -- ./install/bin/gimp-console-2.8 --verbose -d -f @@</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/ed1854d4-10f8-455f-8dfc-d67ee8c55b84" alt="image"></p>
<p>笔记:</p>
<ul>
<li>gimp-console-2.8是GIMP的控制台版本</li>
<li>我建议启用确定性突变（-D）</li>
<li>代码中还有一个无限循环的bug，所以我们需要设置一个较低的超时限制(例如-t 100)。此超时限制取决于您的机器功能，因此您需要根据具体情况对其进行调整</li>
</ul>
<p>几分钟后可以看见有多个崩溃</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/776dba22-7ddd-4db1-a53a-324e1e44729d" alt="Image2"></p>
<h5 id="4、Triage"><a href="#4、Triage" class="headerlink" title="4、Triage"></a>4、Triage</h5><p>ASan跟踪可能看起来像</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/be32a51f-edc7-4284-9563-1c4bf26ae496" alt="image3"></p>
<h5 id="5、修复问题"><a href="#5、修复问题" class="headerlink" title="5、修复问题"></a>5、修复问题</h5><p>修复这两个bug后重建目标，并检查PoC不再使程序崩溃</p>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>通过这个实验，我了解了<strong>CVE-2016-4994</strong>漏洞，学会如何使用持久模式加快模糊测试，如何模糊交互&#x2F; GUI应用程序</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/31/Exercise%206%20-%20GIMP/" data-id="clktgz1jj0001p8vf984d33bg" data-title="Exercise 6 - GIMP" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Exercise 4 - LibTIFF" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/29/Exercise%204%20-%20LibTIFF/" class="article-date">
  <time class="dt-published" datetime="2023-07-29T12:03:56.000Z" itemprop="datePublished">2023-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/29/Exercise%204%20-%20LibTIFF/">Exercise 4 - LibTIFF</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Exercise-4-LibTIFF"><a href="#Exercise-4-LibTIFF" class="headerlink" title="Exercise 4 - LibTIFF"></a>Exercise 4 - LibTIFF</h3><h4 id="一、实验背景"><a href="#一、实验背景" class="headerlink" title="一、实验背景"></a>一、实验背景</h4><p><strong>CVE-2016-9297</strong>是一个越界读取漏洞，可以通过制作TIFF_SETGET_C16ASCII或TIFF_SETGET_C32_ASCII标签值触发。越界读取是当程序读取数据超过预期缓冲区的末尾或开始之前时发生的漏洞。因此，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息。</p>
<p>越界读取漏洞（<a target="_blank" rel="noopener" href="https://cwe.mitre.org/data/definitions/125.html%EF%BC%89">https://cwe.mitre.org/data/definitions/125.html）</a></p>
<h4 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h4><p>模糊<strong>LibTIFF</strong>图像库，在libtiff 4.0.4中找到<a target="_blank" rel="noopener" href="https://www.cvedetails.com/cve/CVE-2016-9297/"><strong>CVE-2016-9297</strong></a>漏洞&#x2F;PoC，以测量崩溃&#x2F;PoC的代码覆盖数据</p>
<h4 id="三、实验环境："><a href="#三、实验环境：" class="headerlink" title="三、实验环境："></a>三、实验环境：</h4><p>win10，VMware，Ubuntu 20.04.2 LTS（虚拟机用户名密码均为fuzz）</p>
<h4 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h4><h5 id="1、下载并构建目标"><a href="#1、下载并构建目标" class="headerlink" title="1、下载并构建目标"></a>1、下载并构建目标</h5><p>得到模糊目标，为要模糊化的项目创建一个新目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir fuzzing_tiff &amp;&amp; cd fuzzing_tiff/</span><br></pre></td></tr></table></figure>

<p>下载并解压libtiff 4.0.4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.osgeo.org/libtiff/tiff-4.0.4.tar.gz</span><br><span class="line">tar -xzvf tiff-4.0.4.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/9291b692-50f9-4453-bf58-24c524d9607c" alt="image"></p>
<p>构建并安装libtiff</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd tiff-4.0.4/</span><br><span class="line">./configure --prefix=&quot;$HOME/fuzzing_tiff/install/&quot; --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/9e3eec16-353a-479d-98d4-c9c87564ad5e" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/951ec19d-b751-4e5b-a68e-f0d650c65d64" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/272999fa-1623-49fb-ac98-4f47afae76b1" alt="image"></p>
<p>作为目标二进制，可以模糊’ ‘ tiffinfo ‘ ‘二进制位于’ ‘ &#x2F;bin ‘ ‘文件夹，使用’ ‘ &#x2F;test&#x2F;images&#x2F; ‘ ‘文件夹中的示例图像作为种子输入语料库。</p>
<p>测试工作是否正常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w $HOME/fuzzing_tiff/tiff-4.0.4/test/images/palette-1c-1b.tiff</span><br></pre></td></tr></table></figure>

<p>看到如下页面说明正常</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/3c61fc6b-be71-4a36-a358-144d5ef0616d" alt="image"></p>
<p>在最后一个命令行中，启用了所有这些标志:”-j -c -r -s -w”。这是为了提高代码覆盖率，增加发现bug的机会。</p>
<p>但是我们如何度量给定输入情况的代码覆盖率呢?</p>
<h5 id="2、代码覆盖率"><a href="#2、代码覆盖率" class="headerlink" title="2、代码覆盖率"></a>2、代码覆盖率</h5><p>代码覆盖率是一个软件度量，显示每行代码被触发的次数。通过使用代码覆盖率，我们将了解哪些部分的代码已经被模糊器到达，并可视化模糊过程。</p>
<p>安装lcov</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install lcov</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/8b0a9dc5-650e-4803-9ca9-e36026a2661d" alt="image"></p>
<p>用“——coverage”标志重新构建libTIFF(编译器和链接器)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME/fuzzing_tiff/install</span><br><span class="line">cd $HOME/fuzzing_tiff/tiff-4.0.4/</span><br><span class="line">make clean</span><br><span class="line">  </span><br><span class="line">CFLAGS=&quot;--coverage&quot; LDFLAGS=&quot;--coverage&quot; ./configure --prefix=&quot;$HOME/fuzzing_tiff/install/&quot; --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/d433cee5-46a3-49f4-8167-77410b2df996" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/9d6aa61c-41b2-42ed-bcf9-e20ecf36d270" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/a421a445-6681-4da9-9ffe-9dd902ddb3a7" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/d7329e66-432f-4b83-b471-0fbefd78454f" alt="image"></p>
<p>通过输入以下代码来收集代码覆盖率数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/fuzzing_tiff/tiff-4.0.4/</span><br><span class="line">lcov --zerocounters --directory ./</span><br><span class="line">lcov --capture --initial --directory ./ --output-file app.info</span><br><span class="line">$HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w $HOME/fuzzing_tiff/tiff-4.0.4/test/images/palette-1c-1b.tiff</span><br><span class="line">lcov --no-checksum --directory ./ --capture --output-file app2.info</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/c7110cb6-9ea8-42b6-9d41-c45f5d80f90c" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/1c3dbde4-b2dc-4fff-90df-28af3a8030a6" alt="image"></p>
<p>每一个命令的解释:</p>
<ul>
<li><code>lcov --zerocounters --directory ./</code> : 重置之前的计数器</li>
<li><code>lcov --capture --initial --directory ./ --output-file app.info</code> : 返回“基线”覆盖率数据文件，该文件包含每个测量行的零覆盖率</li>
<li><code>$HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w $HOME/fuzzing_tiff/tiff-4.0.4/test/images/palette-1c-1b.tiff</code> : 运行需要分析的应用程序，可以使用不同的输入多次运行它</li>
<li><code>lcov --no-checksum --directory ./ --capture --output-file app2.info</code>: 将当前覆盖状态保存到app2.info文件中</li>
</ul>
<p>最后，生成HTML输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">genhtml --highlight --legend -output-directory ./html-coverage/ ./app2.info</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/cce49fe6-c4cf-4399-8e8b-93192e7f0ed2" alt="image"></p>
<p>如果一切顺利，代码覆盖率报告将在“html-coverage”文件夹中创建。只要打开<code>./html-coverage/index.html</code>文件，可以看到如下内容</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/ac681a9e-0274-4858-9968-aa026d149254" alt="image"></p>
<p>可以浏览不同的文件夹和文件，并查看每行执行的次数</p>
<h5 id="3、fuzzing"><a href="#3、fuzzing" class="headerlink" title="3、fuzzing"></a>3、fuzzing</h5><p>要编译启用了ASAN的libtiff</p>
<p>首先，要清理所有之前编译过的目标文件和可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME/fuzzing_tiff/install</span><br><span class="line">cd $HOME/fuzzing_tiff/tiff-4.0.4/</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/09a2593d-14da-4ac8-af56-c8da612bbc1e" alt="image"></p>
<p>调用make之前设置AFL_USE_ASAN&#x3D;1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --prefix=&quot;$HOME/fuzzing_tiff/install/&quot; --disable-shared</span><br><span class="line">AFL_USE_ASAN=1 make -j4</span><br><span class="line">AFL_USE_ASAN=1 make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/11b06f56-0bfc-4cec-9edf-facbfe023453" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7600f523-f6ee-4865-b184-2e2ac0801bb5" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/db8de18a-f4fd-4e20-ba92-df2997d3d018" alt="image"></p>
<p>使用以下命令运行fuzzer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i $HOME/fuzzing_tiff/tiff-4.0.4/test/images/ -o $HOME/fuzzing_tiff/out/ -s 123 -- $HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w @@</span><br></pre></td></tr></table></figure>

<p>几分钟后可以看见有多个崩溃</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/810f991e-914f-4399-be93-bebb5a8d3d3f" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/2a43fc75-44f5-4e70-875d-b12e612e0bd3" alt="image"></p>
<h5 id="4、Triage"><a href="#4、Triage" class="headerlink" title="4、Triage"></a>4、Triage</h5><p>ASan跟踪可能看起来如下图所示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/fuzzing_tiff/install/bin/tiffinfo -D -j -c -r -s -w &#x27;/home/fuzz/fuzzing_tiff/out/default/crashes/id:000000,sig:06,src:000000,time:1806,execs:1009,op:havoc,rep:1&#x27;</span><br></pre></td></tr></table></figure>

<p>可以得到一个很好的奔溃摘要，包括执行跟踪</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/d2cd658d-76fb-46c4-b06c-bd53d3b12cca" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/875f63bb-309b-41e4-8953-5c656452de7d" alt="image"></p>
<p>报错信息</p>
<p>AddressSanitizer: heap-buffer-overflow on address 0x602000000071 at pc 0x0000002aafc2 bp 0x7ffd9d5ea570 sp 0x7ffd9d5e9d30</p>
<p>堆溢出</p>
<h5 id="5、代码覆盖度量"><a href="#5、代码覆盖度量" class="headerlink" title="5、代码覆盖度量"></a>5、代码覆盖度量</h5><p>尝试度量PoC的代码覆盖率。<strong>需要获得一个覆盖率html报告</strong>，类似于上面的例子。</p>
<h5 id="6、修复问题"><a href="#6、修复问题" class="headerlink" title="6、修复问题"></a>6、修复问题</h5><p>修复bug后重建目标，并检查PoC不再使程序崩溃</p>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>通过这个实验，我了解了<strong>CVE-2016-9297</strong>漏洞，学会如何使用LCOV来衡量代码覆盖率，如何使用代码覆盖率数据来提高模糊测试的有效性、</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/29/Exercise%204%20-%20LibTIFF/" data-id="clkr6x7zn0000jgvf5oxhc4ry" data-title="Exercise 4 - LibTIFF" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Exercise 3 - TCPdump" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/28/Exercise%203%20-%20TCPdump/" class="article-date">
  <time class="dt-published" datetime="2023-07-28T15:20:46.000Z" itemprop="datePublished">2023-07-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/28/Exercise%203%20-%20TCPdump/">Exercise 3 - TCPdump</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Exercise-3-TCPdump"><a href="#Exercise-3-TCPdump" class="headerlink" title="Exercise 3 - TCPdump"></a>Exercise 3 - TCPdump</h3><h4 id="一、实验背景"><a href="#一、实验背景" class="headerlink" title="一、实验背景"></a>一、实验背景</h4><p><strong>CVE-2017-13028</strong>是一个越界读取漏洞，可以通过BOOTP数据包(引导协议)触发，越界读取是当程序读取数据超过预期缓冲区的末尾或开始之前时发生的漏洞。因此，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息。</p>
<p>越界读取漏洞（<a target="_blank" rel="noopener" href="https://cwe.mitre.org/data/definitions/125.html%EF%BC%89">https://cwe.mitre.org/data/definitions/125.html）</a></p>
<p>**AddressSanitizer (ASan)**是C和c++的快速内存错误检测器。它最初是由谷歌(Konstantin Serebryany, Derek Bruening, Alexander Potapenko, Dmitry Vyukov)开发的，并于2011年5月首次发布。</p>
<p>它由编译器插装模块和运行时库组成。该工具能够查找对堆、堆栈和全局对象的越界访问，以及use-after-free、double-free和内存泄漏错误。</p>
<p>AddressSanitizer是开源的，并且从3.1版开始集成到LLVM编译器工具链中。虽然它最初是作为LLVM的一个项目开发的，但它已被移植到GCC，并包含在GCC版本&gt;&#x3D; 4.8中</p>
<p>AddressSanitizer（<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/AddressSanitizer.html%EF%BC%89">https://clang.llvm.org/docs/AddressSanitizer.html）</a></p>
<h4 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h4><p>模糊<strong>TCPdump</strong>数据包分析器。目标是在TCPdump 4.9.2中找到<a target="_blank" rel="noopener" href="https://www.cvedetails.com/cve/CVE-2017-13028/"><strong>CVE-2017-13028</strong></a>漏洞</p>
<h4 id="三、实验环境："><a href="#三、实验环境：" class="headerlink" title="三、实验环境："></a>三、实验环境：</h4><p>win10，VMware，Ubuntu 20.04.2 LTS（虚拟机用户名密码均为fuzz）</p>
<h4 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h4><h5 id="1、下载并构建目标"><a href="#1、下载并构建目标" class="headerlink" title="1、下载并构建目标"></a>1、下载并构建目标</h5><p>得到模糊目标，为要模糊化的项目创建一个新目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir fuzzing_tcpdump &amp;&amp; cd fuzzing_tcpdump/</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/08529bcf-9f4f-44f8-9b8a-fc8c80dd303f" alt="image"></p>
<p>下载并解压tcpdump-4.9.2.tar.gz</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/the-tcpdump-group/tcpdump/archive/refs/tags/tcpdump-4.9.2.tar.gz</span><br><span class="line">tar -xzvf tcpdump-4.9.2.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/bfafe340-fe3e-4521-aa84-99e79d11de50" alt="image"></p>
<p>下载libpcap（TCPdump需要的一个跨平台库）并解压libpcap-1.8.0.tar.gz</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/the-tcpdump-group/libpcap/archive/refs/tags/libpcap-1.8.0.tar.gz</span><br><span class="line">tar -xzvf libpcap-1.8.0.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/981bf9e9-66de-4a6e-b4c3-4327c333682f" alt="image"></p>
<p>我们需要将“libpcap-libpcap-1.8.0”重命名为“libpcap-1.8.0”。否则，tcpdump找不到libpcap的本地路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv libpcap-libpcap-1.8.0/ libpcap-1.8.0</span><br></pre></td></tr></table></figure>

<p>构建并安装libpcap</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/fuzzing_tcpdump/libpcap-1.8.0/</span><br><span class="line">./configure --enable-shared=no</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/974188b3-5f85-4f20-a6f2-7dcc627c78c1" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/b003c591-59df-4828-95e4-f362af91c420" alt="image"></p>
<p>构建并安装tcpdump</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/fuzzing_tcpdump/tcpdump-tcpdump-4.9.2/</span><br><span class="line">./configure --prefix=&quot;$HOME/fuzzing_tcpdump/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/460187ad-7234-43ad-bec8-63e8178e715d" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/9eedf66f-4119-400d-bc4d-d58e8b58bf94" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7ebb9a99-b83b-491c-91f4-bdc587c57128" alt="image"></p>
<p>测试工作是否正常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/fuzzing_tcpdump/install/sbin/tcpdump -h</span><br></pre></td></tr></table></figure>

<p>看到如下页面说明正常</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/264ba0de-6a31-42f3-9b6f-c7edd627277b" alt="image"></p>
<p>tcpdump version 4.9.2</p>
<p>libpcap version 1.8.0</p>
<p>检查版本号是否与实验手册的一致，若一致，则继续下面的实验</p>
<h5 id="2、创建种子语料库"><a href="#2、创建种子语料库" class="headerlink" title="2、创建种子语料库"></a>2、创建种子语料库</h5><p>可以在“.pcap”中找到许多. pcap示例，“&#x2F;tests”文件夹中。你可以用下面的命令行运行这些.pcap文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/fuzzing_tcpdump/install/sbin/tcpdump -vvvvXX -ee -nn -r [.pcap file]</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/fuzzing_tcpdump/install/sbin/tcpdump -vvvvXX -ee -nn -r ./tests/geneve.pcap</span><br></pre></td></tr></table></figure>

<p>然后会看到如下页面</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/d9cb8f69-7ae5-42bf-b696-979a1f1486c8" alt="image"></p>
<h5 id="3、构建时启用ASan"><a href="#3、构建时启用ASan" class="headerlink" title="3、构建时启用ASan"></a>3、构建时启用ASan</h5><p>构建启用了ASAN的tcpdump(和libpcap)</p>
<p>要清理所有之前编译过的目标文件和可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME/fuzzing_tcpdump/install</span><br><span class="line">cd $HOME/fuzzing_tcpdump/libpcap-1.8.0/</span><br><span class="line">make clean</span><br><span class="line"></span><br><span class="line">cd $HOME/fuzzing_tcpdump/tcpdump-tcpdump-4.9.2/</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/3ca726e2-3cf7-4e8d-89eb-a7e5024694b0" alt="image"></p>
<p>调用configure和make之前设置AFL_USE_ASAN&#x3D;1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/fuzzing_tcpdump/libpcap-1.8.0/</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_tcpdump/install/&quot;</span><br><span class="line">AFL_USE_ASAN=1 make</span><br><span class="line"></span><br><span class="line">cd $HOME/fuzzing_tcpdump/tcpdump-tcpdump-4.9.2/</span><br><span class="line">AFL_USE_ASAN=1 CC=afl-clang-lto ./configure --prefix=&quot;$HOME/fuzzing_tcpdump/install/&quot;</span><br><span class="line">AFL_USE_ASAN=1 make</span><br><span class="line">AFL_USE_ASAN=1 make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/73a731ea-8db7-45bb-9120-360aa22920bf" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/f83b04a9-8e88-4db5-8164-98e5b97ce159" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/98bb0804-ab9a-41b7-8bba-182e0e0fa707" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/5cfcf84a-4ed9-4218-892e-76eec8896e49" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/03482b76-83ce-4a72-9b7a-d5123b3c6d87" alt="image"></p>
<p>Afl-clang-lto编译可能需要几分钟才能完成</p>
<h5 id="4、fuzzing"><a href="#4、fuzzing" class="headerlink" title="4、fuzzing"></a>4、fuzzing</h5><p>使用以下命令运行fuzzer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -m none -i $HOME/fuzzing_tcpdump/tcpdump-tcpdump-4.9.2/tests/ -o $HOME/fuzzing_tcpdump/out/ -s 123 -- $HOME/fuzzing_tcpdump/install/sbin/tcpdump -vvvvXX -ee -nn -r @@</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/1b93ccc5-cd10-46e8-b67d-a00d8d92e6f7" alt="image"></p>
<p>注意:64位系统上的ASAN需要大量虚拟内存。这就是为什么我在AFL中设置了禁用内存限制的标志“-m none”</p>
<p>几小时后可以看见有多个崩溃</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/9afc9e90-8010-4369-9714-a521fa4b27c7" alt="image"></p>
<h5 id="5、Triage"><a href="#5、Triage" class="headerlink" title="5、Triage"></a>5、Triage</h5><p>调试用ASan构建的程序，需要给程序提供崩溃文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/fuzzing_tcpdump/install/sbin/tcpdump -vvvvXX -ee -nn -r &#x27;/home/fuzz/fuzzing_tcpdump/out/default/crashes/id:000000,sig:06,src:003788,time:8574962,execs:1212760,op:havoc,rep:3&#x27;</span><br></pre></td></tr></table></figure>

<p>可以得到一个很好的奔溃摘要，包括执行跟踪</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/f86b6892-bc13-46f9-a1c8-7f4372793def" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/ca42c834-fc39-4701-a80d-18eb4d768d13" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/f07ba962-ecff-40d8-9447-c445a1501cee" alt="image"></p>
<p>报错信息</p>
<p>AddressSanitizer: heap-buffer-overflow on address 0x6100000000ff at pc 0x0000003cee45 bp 0x7fff77cbed90 sp 0x7fff77cbe538</p>
<p>堆溢出</p>
<h5 id="6、修复问题"><a href="#6、修复问题" class="headerlink" title="6、修复问题"></a>6、修复问题</h5><p><a target="_blank" rel="noopener" href="https://github.com/the-tcpdump-group/tcpdump/commit/85078eeaf4bf8fcdc14a4e79b516f92b6ab520fc#diff-05f854a9033643de07f0d0059bc5b98f3b314eeb1e2499ea1057e925e6501ae8L381">https://github.com/the-tcpdump-group/tcpdump/commit/85078eeaf4bf8fcdc14a4e79b516f92b6ab520fc#diff-05f854a9033643de07f0d0059bc5b98f3b314eeb1e2499ea1057e925e6501ae8L381</a></p>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>通过这个实验，我了解了<strong>CVE-2017-13028</strong>漏洞，了解运行时内存错误检测工具**ASan (Address Sanitizer)**，学会如何使用ASAN模糊目标，使用ASan对崩溃进行分类</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/28/Exercise%203%20-%20TCPdump/" data-id="clkrvnqux0000kkvfc4kx342f" data-title="Exercise 3 - TCPdump" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Exercise 2 - libexif" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/27/Exercise%202%20-%20libexif/" class="article-date">
  <time class="dt-published" datetime="2023-07-27T15:32:15.000Z" itemprop="datePublished">2023-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/27/Exercise%202%20-%20libexif/">Exercise 2 - libexif</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Exercise-2-libexif"><a href="#Exercise-2-libexif" class="headerlink" title="Exercise 2 - libexif"></a>Exercise 2 - libexif</h3><h4 id="一、实验背景"><a href="#一、实验背景" class="headerlink" title="一、实验背景"></a>一、实验背景</h4><p><strong>CVE-2009-3895</strong>是一个基于堆的缓冲区溢出，可以通过无效的EXIF图像触发。基于堆的缓冲区溢出是发生在堆数据区域的一种缓冲区溢出，它通常与显式动态内存管理(使用malloc()和free()函数进行分配&#x2F;回收)有关。因此，远程攻击者可以利用此问题在使用受影响库的应用程序上下文中执行任意代码。</p>
<p>基于堆的缓冲区溢出漏洞（<a target="_blank" rel="noopener" href="https://cwe.mitre.org/data/definitions/122.html%EF%BC%89">https://cwe.mitre.org/data/definitions/122.html）</a></p>
<p><strong>CVE-2012-2836</strong>是一个越界读取漏洞，可以通过带有精心制作的EXIF标签的图像触发。越界读取是当程序读取数据超过预期缓冲区的末尾或开始之前时发生的漏洞。因此，它允许远程攻击者导致拒绝服务或可能从进程内存中获取潜在的敏感信息。</p>
<p>越界读取漏洞（<a target="_blank" rel="noopener" href="https://cwe.mitre.org/data/definitions/125.html%EF%BC%89">https://cwe.mitre.org/data/definitions/125.html）</a></p>
<h4 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h4><p>这次我们将模糊<strong>libexif</strong> EXIF解析库。目标是在libxif 0.6.14中找到<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3895"><strong>CVE-2009-3895</strong></a>和<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2836"><strong>CVE-2012-2836</strong></a>的崩溃&#x2F;PoC。</p>
<h4 id="三、实验环境："><a href="#三、实验环境：" class="headerlink" title="三、实验环境："></a>三、实验环境：</h4><p>win10，VMware，Ubuntu 20.04.2 LTS（虚拟机用户名密码均为fuzz）</p>
<h4 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h4><h5 id="1、下载并构建目标"><a href="#1、下载并构建目标" class="headerlink" title="1、下载并构建目标"></a>1、下载并构建目标</h5><p>为模糊的项目创建一个新目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir fuzzing_libexif &amp;&amp; cd fuzzing_libexif/</span><br></pre></td></tr></table></figure>

<p>下载并解压libexif-0.6.14</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/libexif/libexif/archive/refs/tags/libexif-0_6_14-release.tar.gz</span><br><span class="line">tar -xzvf libexif-0_6_14-release.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/6543f29e-5e52-4ed6-999c-597161314a56" alt="image"></p>
<p>构建并安装libexif</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd libexif-libexif-0_6_14-release/</span><br><span class="line">sudo apt-get install autopoint libtool gettext libpopt-dev</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/5e1c7727-dce4-41eb-95dc-bff5012fb3ff" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/83e655dd-f4d6-47ea-94df-31c9d62dba34" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/974d2755-eeb5-4ae1-b5b1-3cc5fc523a92" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7c84d35d-8784-486c-b206-e7e8a9e53568" alt="image"></p>
<p><img src="C:\Users\15646\AppData\Roaming\Typora\typora-user-images\image-20230727232107643.png" alt="image-20230727232107643"></p>
<h5 id="2、选择一个接口应用程序"><a href="#2、选择一个接口应用程序" class="headerlink" title="2、选择一个接口应用程序"></a>2、选择一个接口应用程序</h5><p>libexif是一个库，我们需要另一个应用程序来使用这个库，这个应用程序将被模糊化。对于这个任务，我们将使用<strong>exif command-line</strong>，下载并解压exif command-line 0.6.15:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/fuzzing_libexif</span><br><span class="line">wget https://github.com/libexif/exif/archive/refs/tags/exif-0_6_15-release.tar.gz</span><br><span class="line">tar -xzvf exif-0_6_15-release.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/473d3e7e-3ab3-4ae1-9c98-5640bddcaa2c" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/10a19b33-857d-4b49-8d17-efb4e7254066" alt="image"></p>
<p>构建并安装exif command-line实用程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd exif-exif-0_6_15-release/</span><br><span class="line">autoreconf -fvi</span><br><span class="line">./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/install/&quot; PKG_CONFIG_PATH=$HOME/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/2971a8cb-5f5a-40d6-9af5-5b99c740b55a" alt="image"></p>
<p><img src="C:\Users\15646\AppData\Roaming\Typora\typora-user-images\image-20230727232415273.png" alt="image-20230727232415273"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/b3fd1cbf-249c-4a2d-b601-f4193f815c12" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/f0807bd9-9ea0-49b5-9481-683f38202257" alt="image"></p>
<p>测试是否正常工作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/fuzzing_libexif/install/bin/exif</span><br></pre></td></tr></table></figure>

<p>看到如下页面说明工作正常</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/3f53db47-04ea-461c-8c9e-859ffd12f4da" alt="image"></p>
<h5 id="3、创建种子语料库"><a href="#3、创建种子语料库" class="headerlink" title="3、创建种子语料库"></a>3、创建种子语料库</h5><p>现在我们需要一些出口样本。我们将使用以下repo中的样例图像:<a target="_blank" rel="noopener" href="https://github.com/ianare/exif-samples%E3%80%82%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8B%E6%8C%87%E4%BB%A4%E4%B8%8B%E8%BD%BD">https://github.com/ianare/exif-samples。通过以下指令下载</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/fuzzing_libexif</span><br><span class="line">wget https://github.com/ianare/exif-samples/archive/refs/heads/master.zip</span><br><span class="line">unzip master.zip</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7453ee21-bca8-4d98-9f25-350141d0e7f3" alt="image"></p>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/fuzzing_libexif/install/bin/exif $HOME/fuzzing_libexif/exif-samples-master/jpg/Canon_40D_photoshop_import.jpg</span><br></pre></td></tr></table></figure>

<p>可以看到如下输出</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/3a12071e-4332-4383-9d85-1612dbc00b38" alt="image"></p>
<h5 id="4、Afl-clang-lto"><a href="#4、Afl-clang-lto" class="headerlink" title="4、Afl-clang-lto"></a>4、Afl-clang-lto</h5><p>使用<strong>afl-clang-lto</strong>作为编译器来构建libexif。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME/fuzzing_libexif/install</span><br><span class="line">cd $HOME/fuzzing_libexif/libexif-libexif-0_6_14-release/</span><br><span class="line">make clean</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/fuzzing_libexif/exif-exif-0_6_15-release</span><br><span class="line">make clean</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=afl-clang-lto ./configure --enable-shared=no --prefix=&quot;$HOME/fuzzing_libexif/install/&quot; PKG_CONFIG_PATH=$HOME/fuzzing_libexif/install/lib/pkgconfig</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/110ef19c-eaf2-45bd-a3db-de5b980cc57a" alt="image"></p>
<p><img src="C:\Users\15646\AppData\Roaming\Typora\typora-user-images\image-20230727233607562.png" alt="image-20230727233607562"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/6e6e8f30-0b1e-4603-94d4-65139cd9fede" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/c58fa0c8-927b-4c29-bd92-ec842081e184" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/412bb374-a138-4d29-b912-96ebfc9bae38" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/fbdc3cb0-7f3f-4f5a-b68e-44ce3cea911e" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/d79bf6e4-f593-49d0-95fb-efd4fc1a2c39" alt="image"></p>
<p><img src="C:\Users\15646\AppData\Roaming\Typora\typora-user-images\image-20230727233940330.png" alt="image-20230727233940330"></p>
<p>使用了<strong>afl-clang-lto</strong>而不是<strong>afl-clang-fast</strong>。一般来说，<strong>afl-clang-lto</strong>是最好的选择，因为它是一个无冲突的工具，而且它比<strong>afl-clang-fast</strong>快。</p>
<p>如果不确定何时使用<strong>afl-clang-lto</strong>或<strong>afl-clang-fast</strong>，可以检查从[AFLplusplus:检测目标]提取的下图(<a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus#1-instrumenting-that-target">https://github.com/AFLplusplus/AFLplusplus#1-instrumenting-that-target</a>)</p>
<p>](<a target="_blank" rel="noopener" href="https://github.com/AFLplusplus/AFLplusplus#1-instrumenting-that-target">https://github.com/AFLplusplus/AFLplusplus#1-instrumenting-that-target</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------+</span><br><span class="line">| clang/clang++ 11+ is available | --&gt; use LTO mode (afl-clang-lto/afl-clang-lto++)</span><br><span class="line">+--------------------------------+     see [instrumentation/README.lto.md](instrumentation/README.lto.md)</span><br><span class="line">    |</span><br><span class="line">    | if not, or if the target fails with LTO afl-clang-lto/++</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">+---------------------------------+</span><br><span class="line">| clang/clang++ 6.0+ is available | --&gt; use LLVM mode (afl-clang-fast/afl-clang-fast++)</span><br><span class="line">+---------------------------------+     see [instrumentation/README.llvm.md](instrumentation/README.llvm.md)</span><br><span class="line">    |</span><br><span class="line">    | if not, or if the target fails with LLVM afl-clang-fast/++</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line"> +--------------------------------+</span><br><span class="line"> | gcc 5+ is available            | -&gt; use GCC_PLUGIN mode (afl-gcc-fast/afl-g++-fast)</span><br><span class="line"> +--------------------------------+    see [instrumentation/README.gcc_plugin.md](instrumentation/README.gcc_plugin.md) and</span><br><span class="line">                                       [instrumentation/README.instrument_list.md](instrumentation/README.instrument_list.md)</span><br><span class="line">    |</span><br><span class="line">    | if not, or if you do not have a gcc with plugin support</span><br><span class="line">    |</span><br><span class="line">    v</span><br><span class="line">   use GCC mode (afl-gcc/afl-g++) (or afl-clang/afl-clang++ for clang)</span><br></pre></td></tr></table></figure>

<h4 id="5、fuzzing"><a href="#5、fuzzing" class="headerlink" title="5、fuzzing"></a>5、fuzzing</h4><p>使用以下命令运行fuzzer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i $HOME/fuzzing_libexif/exif-samples-master/jpg/ -o $HOME/fuzzing_libexif/out/ -s 123 -- $HOME/fuzzing_libexif/install/bin/exif @@</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/78f8b744-54ce-4d0c-b39d-819491dfad7d" alt="image"></p>
<p>几分钟后可以看见有多个崩溃</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/b67623b8-6a50-4130-9ecc-3605eb0c0f83" alt="image"></p>
<p>可以在这里找到崩溃的图像文件</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/6920c7f3-ef27-450d-bc94-8a719b8cfd51" alt="image"></p>
<h5 id="6、动态调试"><a href="#6、动态调试" class="headerlink" title="6、动态调试"></a>6、动态调试</h5><p>编译出带调试信息的可执行文件</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/9615bc59-6331-4782-9e3e-978bf3170239" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/2e6a9d0d-4a1c-45d0-ad8b-1d2fd8236f38" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/b71abd7e-80d5-4908-b4b9-06d0273d1b51" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/96c5f039-dc94-41e5-93c9-f2ef5d802ff2" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/bb07280f-84e4-40a3-86da-81b1ae37c7ac" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/2cd7f21f-dcfa-4b47-9ddc-4a87efbb794a" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/8c87e2c4-8d92-4f0a-ab71-e744d772344e" alt="image"></p>
<p><img src="C:\Users\15646\AppData\Roaming\Typora\typora-user-images\image-20230728003925454.png" alt="image-20230728003925454"></p>
<p>放到gdb中，跑出clash</p>
<h6 id="clash1"><a href="#clash1" class="headerlink" title="clash1"></a>clash1</h6><p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/d21d484c-3feb-4091-8cb7-a33113e8449c" alt="image"></p>
<p>报错信息**Program received signal SIGSEGV, Segmentation fault.**存在内存泄漏</p>
<p>报错位置<strong>in exif_data_load_data (data&#x3D;0x4538c0, d_orig&#x3D;<optimized out>, ds_orig&#x3D;<optimized out>) at exif-utils.c:94 94 return ((buf[1] &lt;&lt; 8) | buf[0]);</strong></p>
<p>注意这里的报错，内存地址无法访问，再看地址，猜测为堆缓冲区溢出</p>
<h6 id="clash2"><a href="#clash2" class="headerlink" title="clash2"></a>clash2</h6><p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/c527947c-bf6e-409e-9fcb-4dbd094d6396" alt="image"></p>
<p>报错信息**Program received signal SIGSEGV, Segmentation fault.**存在内存泄露</p>
<p>报错位置<strong>in exif_data_load_data (data&#x3D;0x4538c0, d_orig&#x3D;<optimized out>, ds_orig&#x3D;<optimized out>) at exif-utils.c:94</strong></p>
<h6 id="clash3"><a href="#clash3" class="headerlink" title="clash3"></a>clash3</h6><p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/084afe63-c7a2-486b-9e8e-d5509d4efe19" alt="image"></p>
<p>报错信息**Program received signal SIGSEGV, Segmentation fault.**存在内存泄露</p>
<p>报错位置<strong>in exif_data_load_data (data&#x3D;0x4538c0, d_orig&#x3D;<optimized out>, ds_orig&#x3D;<optimized out>) at exif-utils.c:94</strong></p>
<h5 id="7、漏洞修复"><a href="#7、漏洞修复" class="headerlink" title="7、漏洞修复"></a>7、漏洞修复</h5><p><a target="_blank" rel="noopener" href="https://github.com/libexif/libexif/commit/8ce72b7f81e61ef69b7ad5bdfeff1516c90fa361">https://github.com/libexif/libexif/commit/8ce72b7f81e61ef69b7ad5bdfeff1516c90fa361</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/libexif/libexif/commit/00986f6fa979fe810b46e376a462c581f9746e06">https://github.com/libexif/libexif/commit/00986f6fa979fe810b46e376a462c581f9746e06</a></p>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>通过这个实验，我了解了<strong>CVE-2009-3895</strong>漏洞和<strong>CVE-2012-2836</strong>漏洞，学习了<strong>libexif</strong>，找到一个使用libexif库的接口应用程序，创建一个出口样本的种子语料库使，用afl-clang-lto编译libexif和选择的应用程序，模糊libexif，直到有一些独特的崩溃，分类崩溃以找到每个漏洞的PoC</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/27/Exercise%202%20-%20libexif/" data-id="clklekotu0000m8vf1b0j8wpb" data-title="Exercise 2 - libexif" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Paper-The structure of paper or report in Systems" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/26/Paper-The%20structure%20of%20paper%20or%20report%20in%20Systems/" class="article-date">
  <time class="dt-published" datetime="2023-07-26T15:09:39.000Z" itemprop="datePublished">2023-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/26/Paper-The%20structure%20of%20paper%20or%20report%20in%20Systems/">《The structure of paper/report in Systems》</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="系统中纸张-x2F-报告的结构"><a href="#系统中纸张-x2F-报告的结构" class="headerlink" title="系统中纸张&#x2F;报告的结构"></a>系统中纸张&#x2F;报告的结构</h3><p><a target="_blank" rel="noopener" href="http://www.cs.ucr.edu/~michalis/TECHWRITING/structure.html">结构 (ucr.edu)</a></p>
<p>写论文时要遵循一些规则：</p>
<p>递归性1：每一部分的第一段应该是本节的摘要&#x2F;概述，可以先说“在本节中，我们将介绍…”</p>
<p>递归性2：每个段落中，第一行&#x2F;第二行应该对应于段落的摘要</p>
<p>自上而下：从高层次开始，慢慢增加细节，让读者知道我们想往哪方面扩展</p>
<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>摘要主要介绍我们所做的工作，一段200-300字，用于吸引读者阅读文章</p>
<ol>
<li>本文的目标（1-2行）</li>
<li>工作的动机和重要性（1-2行）</li>
<li>我们工作的结果或贡献（1-2行）最好引用直观或易于解释的指标的数字来量化</li>
</ol>
<h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>提出问题，动机，重要性，主要贡献</p>
<ol>
<li>问题：高层次的定义，意义</li>
<li>以前的工作</li>
<li>我们的贡献</li>
<li>本文结构介绍</li>
</ol>
<h4 id="背景和模型"><a href="#背景和模型" class="headerlink" title="背景和模型"></a>背景和模型</h4><p>定义，场景，模型</p>
<ol>
<li>以前的工作，有助于于我们的工作进行对比，来说我们的工作是否有创新点，与以前的工作相比有什么优势</li>
<li>以前工作的弱点，或在一些方面有什么没有考虑到的东西</li>
<li>我们工作的假设和局限性（只是诚实地提出来，不要谴责我们的工作）</li>
</ol>
<h4 id="我们的想法"><a href="#我们的想法" class="headerlink" title="我们的想法"></a>我们的想法</h4><p>介绍我们的创新点</p>
<p>如果有必要，对我们所作的工作中的一些名词进行介绍，它的定义以及它是如何工作的</p>
<p>详细地介绍细节</p>
<p>对我们在这一节写的内容进行分析</p>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>实验概述：我们了做什么，我们没做什么，为什么</p>
<p>模拟模型或测量基础设施</p>
<p>实验结果</p>
<p>使用标题（粗体） 区分实验（即尺寸对性能的影响，或者甚至更好的尺寸不会影响性能）</p>
<p>每个情节都应该出现一个明确的原因（比如说负载越大，吞吐量越差）</p>
<p>解释每个图：轴，我们看到的，趋势是什么，为什么是这样的趋势</p>
<p>统计，强化结果：置信区间、相关系数等。</p>
<p>每个数字应该是准确的：标题应该是可读的，并且可理解的。</p>
<p>评论，讨论， 解释</p>
<h4 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h4><p>如果我们还有想法，可以在论文中展示出来，比如说重要性，与其他作品的关系，可能的实际应用</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>结论是非常重要的，我们在结论中要</p>
<ol>
<li>对所作的工作进行概述</li>
<li>主要成果和贡献</li>
<li>重要性</li>
<li>实用技巧（帮助别的研究人员使用我们做的东西，避免错误）</li>
<li>未来工作，强调工作的重要性，但是要避免给出自己的想法</li>
</ol>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p>要按照参考文献的标准，必须正确、完整、准确</p>
<h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><p>我们可以再附录写任何我们想写的东西</p>
<ol>
<li>提供额外的结果，以加强我们的论点</li>
<li>通过在这里放一个冗长的证明或讨论一个细节来保持论文的流畅性</li>
<li>解决一个问题，表明我们已经深入思考了这个问题</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/26/Paper-The%20structure%20of%20paper%20or%20report%20in%20Systems/" data-id="clrsrunnb000740vfbcnwbs4c" data-title="《The structure of paper/report in Systems》" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%BB%86%E8%AF%BB/" rel="tag">论文细读</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Exercise 1 - Xpdf" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/25/Exercise%201%20-%20Xpdf/" class="article-date">
  <time class="dt-published" datetime="2023-07-25T15:16:57.000Z" itemprop="datePublished">2023-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/25/Exercise%201%20-%20Xpdf/">Exercise 1 - Xpdf</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="Exercise-1-Xpdf"><a href="#Exercise-1-Xpdf" class="headerlink" title="Exercise 1 - Xpdf"></a>Exercise 1 - Xpdf</h3><h4 id="一、实验背景"><a href="#一、实验背景" class="headerlink" title="一、实验背景"></a>一、实验背景</h4><p>CVE-2019-13288是一个可能通过精心制作的文件导致无线递归的漏洞</p>
<p>程序中每个被调用的函数都在堆栈上分配一个堆栈帧，如果一个函数被递归调用多次，可能会导致堆栈内存耗尽和程序崩溃，因此，远程攻击者可以利用该漏洞进行Dos攻击</p>
<p>非受控制递归漏洞（<a target="_blank" rel="noopener" href="https://cwe.mitre.org/data/definitions/674.html%EF%BC%89">https://cwe.mitre.org/data/definitions/674.html）</a></p>
<h4 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h4><p>模糊<strong>Xpfd（</strong>PDF查看器），目标是在XPDF 3.02中找到<strong>CVE-2019-13288</strong>漏洞</p>
<h4 id="三、实验环境："><a href="#三、实验环境：" class="headerlink" title="三、实验环境："></a>三、实验环境：</h4><p>win10，VMware，Ubuntu 20.04.2 LTS（虚拟机用户名密码均为fuzz）</p>
<h4 id="四、实验步骤"><a href="#四、实验步骤" class="headerlink" title="四、实验步骤"></a>四、实验步骤</h4><h5 id="1、下载并构建目标"><a href="#1、下载并构建目标" class="headerlink" title="1、下载并构建目标"></a>1、下载并构建目标</h5><p>得到模糊目标，为要模糊化的项目创建目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">mkdir fuzzing_xpdf &amp;&amp; cd fuzzing_xpdf/</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7d81d204-27c1-44ec-9b17-ace5348c00e6" alt="image"></p>
<p>安装make和gcc，准备好环境，注意要先更新apt-get，否则会出现错误Unable to locate package build-essential</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update </span><br><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/f47a0423-6e7d-4303-9ce6-e1ba26d1edcc" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/fcdbebff-a669-4cbc-9ba0-ab46c7ed8241" alt="image"></p>
<p>下载Xpdf 3.02压缩包并解压</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz</span><br><span class="line">tar -xvzf xpdf-3.02.tar.gz</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/89111ae7-2c4a-4a5c-98ab-b3263a62bb68" alt="image"></p>
<p>构建Xpdf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd xpdf-3.02</span><br><span class="line">sudo apt update &amp;&amp; sudo apt install -y build-essential gcc</span><br><span class="line">./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/2ec9e65a-cb06-4ca7-baf2-5901cf0c6efd" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/bab69f98-5826-4746-a060-2c41c43c82c6" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/e0fca536-8a93-4388-9c34-99914112154a" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/cd03c3cc-3282-4b32-92e9-285b9b67bd8d" alt="image"></p>
<p>下载一些PDF示例用于后续验证</p>
<p>下载pdf时注意在后面加参数<strong>–no-check-certificate</strong>跳过验证证书，否则会报错unable to establish ssl connection.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME/fuzzing_xpdf</span><br><span class="line">mkdir pdf_examples &amp;&amp; cd pdf_examples</span><br><span class="line">wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf</span><br><span class="line">wget http://www.africau.edu/images/default/sample.pdf –no-check-certificate</span><br><span class="line">wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/4da29f1e-5eb7-4be7-9cd1-a6a2574731bc" alt="image"> </p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/f485bf1a-6186-4faf-80fb-adeccd092781" alt="image"></p>
<p>测试pdfinfo二进制文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/fuzzing_xpdf/install/bin/pdfinfo -box -meta $HOME/fuzzing_xpdf/pdf_examples/helloworld.pdf</span><br></pre></td></tr></table></figure>

<p>看到如下页面说明验证成功</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/2e938476-a1bc-4a18-86d1-01103f16f5d3" alt="image"></p>
<h5 id="2、安装AFL"><a href="#2、安装AFL" class="headerlink" title="2、安装AFL++"></a>2、安装AFL++</h5><p>采用本地安装的方式，首先安装依赖项</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools</span><br><span class="line">sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang </span><br><span class="line">sudo apt-get install -y gcc-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\..*//&#x27;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\..*//&#x27;)-dev</span><br></pre></td></tr></table></figure>

<p>  <img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/73bc8916-fb98-4dd0-b1e3-8480fcfd1369" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/413b7ab7-7445-4ff2-bd39-cbe52f2169dc" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/5f632878-bdaf-44bf-b23f-17d1500051c5" alt="image"></p>
<p>构造AFL++</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $HOME</span><br><span class="line">git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus</span><br><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">make distrib</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\15646\AppData\Roaming\Typora\typora-user-images\image-20230726155938884.png" alt="image-20230726155938884"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/cbc90cfc-387c-426f-b1ee-423707515551" alt="image"></p>
<p>Docker image</p>
<p>安装docker，第一次安装后无法使用docker，使用snap重新下载后可以使用</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/d945678c-160e-4ce9-a689-7057cf053058" alt="image">  </p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/aa42821f-0488-4422-a4a0-9beae001f319" alt="image"></p>
<p>Pull图像，要加上sudo以管理员身份运行，否则会报错connect: permission denied</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull aflplusplus/aflplusplus</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\15646\AppData\Roaming\Typora\typora-user-images\image-20230726161946524.png" alt="image-20230726161946524"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/e6950c13-56f4-40cf-83b0-f63e1eb9c0b9" alt="image"></p>
<p>启动AFLPlusPlus docker容器</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti -v $HOME:/home aflplusplus/aflplusplus</span><br></pre></td></tr></table></figure>

<p>  再运行</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export $HOME=&quot;/home&quot;</span><br></pre></td></tr></table></figure>

<p>输入afl-fuzz运行afl-fuzz，出现下图说明运行成功</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/a94e5375-1782-466b-bbd4-9578eebd7d2a" alt="image"></p>
<h5 id="3、开始实验"><a href="#3、开始实验" class="headerlink" title="3、开始实验"></a>3、开始实验</h5><p>为了使我们的目标应用程序启用插装，我们需要使用AFL的编译器编译代码，首先，我们要清理所有之前编译过的目标文件和可执行文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME/fuzzing_xpdf/install</span><br><span class="line">cd $HOME/fuzzing_xpdf/xpdf-3.02/</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/c5ab56e8-e2f5-4539-923b-a60e81482d07" alt="image"></p>
<p>使用<strong>afl-clang-fast</strong>编译器构建xpdf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export LLVM_CONFIG=&quot;llvm-config-11&quot;</span><br><span class="line">CC=$HOME/AFLplusplus/afl-clang-fast CXX=$HOME/AFLplusplus/afl-clang-fast++ ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/bf922cbb-a81a-4663-bb0f-d16f9fc88a3f" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/5e05cada-e79c-489c-a1c2-25a4d7ed6c3e" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/cc637caf-1fa9-49cd-a5bd-9273570ab123" alt="image"></p>
<p>每个选项的简要说明:</p>
<ul>
<li><em>-i</em> 表示我们必须放置输入大小写的目录(即文件示例)</li>
<li><em>-o</em> 表示afl++存储修改后文件的目录</li>
<li><em>-s</em> 表示使用静态随机种子</li>
<li><em>@@</em> 是AFL将用每个输入文件名替换的占位符目标的命令行</li>
</ul>
<p>fuzzer基本上会运行下面这个命令，用于每个不同的输入文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$HOME/fuzzing_xpdf/install/bin/pdftotext &lt;input-file-name&gt;</span><br><span class="line">$HOME/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure>

<p>使用以下命令运行fuzzer，出现错误如下图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/install/bin/pdftotext @@ $HOME/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/e66e4ddf-8c34-4d1f-912b-3c8151e1ed9d" alt="image"></p>
<p>如果收到消息“Hmm, your system is configured to send core dump notifications to an external utility…”，只要这样做</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo core &gt;/proc/sys/kernel/core_pattern</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/aede7a51-f888-4d7c-8777-e784d6341ae5" alt="image"></p>
<p>再运行fuzzer，几分钟后，可以看到如下页面</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/0d6f6b8b-8dc2-441f-b9c2-10c3a31d7e65" alt="image"></p>
<p>看到<strong>saved crashes</strong>的值，是崩溃的数量</p>
<p>可以在“$HOME&#x2F;fuzzing_xpdf&#x2F;out&#x2F;”目录中找到这些崩溃文件</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/6ed7ae67-a1e6-45d4-bf00-539ed92c879b" alt="image"></p>
<h5 id="4、调试和分类"><a href="#4、调试和分类" class="headerlink" title="4、调试和分类"></a>4、调试和分类</h5><p>通过调试和分类，来找到关于这个bug的信息</p>
<p>1)用指定的文件重现崩溃<br>        2)调试崩溃找出问题所在<br>        3)修复问题</p>
<p>在’ $HOME&#x2F;fuzzing_xpdf&#x2F;out&#x2F; ‘目录中找到与崩溃对应的文件。文件名类于“id:000000,sig:11,src:000526,time:534057,execs:257582,op:havoc,rep:8”</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/87332255-b9e6-4254-bfb5-1ce346fbadd0" alt="image"></p>
<p>将此文件作为输入传递给pdftotext二进制文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$HOME/fuzzing_xpdf/install/bin/pdftotext &#x27;$HOME/fuzzing_xpdf/out/default/crashes/&lt;your_filename&gt;&#x27; $HOME/fuzzing_xpdf/output</span><br></pre></td></tr></table></figure>

<p>它将导致分割错误，并导致程序崩溃</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/11e431fa-dc2d-44ca-b1ca-a7a4431714bc" alt="image"></p>
<p>使用gdb找出使用此输入导致程序崩溃的原因</p>
<p>GDB的简单入门（<a target="_blank" rel="noopener" href="http://people.cs.pitt.edu/~mosse/gdb-note.html%EF%BC%89">http://people.cs.pitt.edu/~mosse/gdb-note.html）</a></p>
<p>首先，使用调试信息重新构建Xpdf，以获得符号堆栈跟踪</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rm -r $HOME/fuzzing_xpdf/install</span><br><span class="line">cd $HOME/fuzzing_xpdf/xpdf-3.02/</span><br><span class="line">make clean</span><br><span class="line">CFLAGS=&quot;-g -O0&quot; CXXFLAGS=&quot;-g -O0&quot; ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/deb41651-02b6-4aaf-8deb-78825b17ed00" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/4bd09b31-40d8-47cd-9fa0-24b13ac652c5" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/90712b71-de40-4af1-b142-0790b922d243" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/6864227f-65ec-4b87-bf5e-c23afee32d6e" alt="image"></p>
<p>运行GDB</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gdb --args $HOME/fuzzing_xpdf/install/bin/pdftotext $HOME/fuzzing_xpdf/out/default/crashes/id:000000,sig:11,src:000526,time:534057,execs:257582,op:havoc,rep:8 $HOME/fuzzing_xpdf/output</span><br><span class="line"></span><br><span class="line">&gt;&gt; run</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7b528a75-eaf5-49d4-bab6-616bf839abc4" alt="image"></p>
<p>正常情况下可看到如下输出</p>
<p>看到<strong>Program received signal SIGSEGV, Segmentation fault</strong>，说明存在内存泄漏</p>
<p>报错位置是<strong>in _int_malloc (av&#x3D;av@entry&#x3D;0x7ffff7c63b80 <main_arena>, bytes&#x3D;bytes@entry&#x3D;4) at malloc.c:3545</strong>，glibc报了个错，显然是堆内存出了问题</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/cea8e247-8de8-49b4-9ee3-11ad70a00558" alt="image"></p>
<p>再输入bt获取回溯</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/3df75385-c961-46de-b88d-34597110861e" alt="image"></p>
<p>滚动调用堆栈，可以看到许多对“Parser::getObj”方法的调用，这些调用似乎表示无限递归。访问<a target="_blank" rel="noopener" href="https://www.cvedetails.com/cve/CVE-2019-13288/%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%8F%8F%E8%BF%B0%E4%BB%8EGDB%E8%8E%B7%E5%BE%97%E7%9A%84%E5%9B%9E%E6%BA%AF%E5%8C%B9%E9%85%8D%E3%80%82">https://www.cvedetails.com/cve/CVE-2019-13288/可以看到描述从GDB获得的回溯匹配。</a></p>
<p>执行流信息，分析一下可以看出调用过程是循环的，判断为无限循环漏洞</p>
<p>根据函数调用找到漏洞位置</p>
<p>从fuzzing_xpdf&#x2F;xpdf-3.02&#x2F;xpdf&#x2F;Parse.cc 94行的makeStream调用，一路跟着报错往下翻就会找到这个套娃</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7ab80d57-b19b-4311-a2ed-cf7e0fa19acc" alt="image"></p>
<h5 id="5、修复问题"><a href="#5、修复问题" class="headerlink" title="5、修复问题"></a>5、修复问题</h5><p>方法</p>
<ol>
<li>修复后重建目标，并检查用例是否不再导致分段错误</li>
<li>安装错误已经修复的Xpdf 4.02，并检查分段错误是否消失</li>
</ol>
<p>我选择的是安装已修复的Xpdf 4.02，对比源代码，发现再Xpdf 4.02的文件Parse.cc中，加了个变量，记录循环次数，超过一定次数就结束进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.xpdfreader.com/old/xpdf-4.02.tar.gz</span><br><span class="line">tar -xvzf xpdf-4.02.tar.gz </span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/e0b54856-a620-4a81-8bc4-999d8ea8710f" alt="image"></p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/54743110-a653-4192-90b2-c8b9b4975dfd" alt="image"></p>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>通过这个实验，我了解了<strong>CVE-2019-13288</strong>漏洞，学习了**AFL++**，如何使用带有插装的afl编译器编译目标，如何启动afl++，如何检测目标崩溃。</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/0d6f6b8b-8dc2-441f-b9c2-10c3a31d7e65" alt="image"></p>
<p>界面信息介绍</p>
<p>process timing：执行时间信息</p>
<p>run time：运行总时间</p>
<p>last new find：距离最近一次发现新路径的时间</p>
<p>last saved crash：距离最近一次保存程序崩溃的时间</p>
<p>last saved hang：距离最近一次保存挂起的时间</p>
<p>overall results：</p>
<p>cycles done：运行的总周期数</p>
<p>corpus count：语料库计数</p>
<p>saved crashes：保存的程序崩溃个数</p>
<p>saved hang：保存的挂起个数</p>
<p>cycle progress：</p>
<p>now processing：当前的测试用例ID（所在输入队列的位置）</p>
<p>runs timed out：超时数量</p>
<p><strong>map coverage：</strong>覆盖率</p>
<p>map density：目前已经命中多少分支元组，与位图可以容纳多少的比例</p>
<p>count coverage：位图中每个被命中的字节平均改变的位数</p>
<p>stage progress：</p>
<p>now trying: 指明当前所用的变异输入的方法</p>
<p>stage execs: 当前阶段的进度指示</p>
<p>total execs: 全局的进度指示</p>
<p>exec speed: 执行速度</p>
<p><strong>findings in depth：</strong>种子变异产生的信息</p>
<p>favored items: 基于最小化算法产生新的更好的路径</p>
<p>new edges on: 基于更好路径产生的新边</p>
<p>total crashes: 基于更好路径产生的崩溃</p>
<p>total tmouts: 基于更好路径产生的超时 包括所有超时的超时</p>
<p>fuzzing strategy yields： 进一步展示了AFL所做的工作，在更有效路径上得到的结果比例，对应上面的now trying</p>
<p>bit flips: 比特位翻转，例如：</p>
<p>bitflip 1&#x2F;1，每次翻转1个bit，按照每1个bit的步长从头开始</p>
<p>bitflip 2&#x2F;1，每次翻转相邻的2个bit，按照每1个bit的步长从头开始</p>
<p>byte flips: 字节翻转</p>
<p>arithmetics: 算术运算，例如：</p>
<p>arith 16&#x2F;8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</p>
<p>know ints: 用于替换的基本都是可能会造成溢出的数，例：</p>
<p>interest 16&#x2F;8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</p>
<p>dictionary: 有以下子阶段：</p>
<p>user extras (over)，从头开始，将用户提供的tokens依次替换到原文件中</p>
<p>user extras (insert)，从头开始，将用户提供的tokens依次插入到原文件中</p>
<p>auto extras (over)，从头开始，将自动检测的tokens依次替换到原文件中</p>
<p>其中，用户提供的tokens，是在词典文件中设置并通过-x选项指定的，如果没有则跳过相应的子阶段。</p>
<p>havoc：顾名思义，是充满了各种随机生成的变异，是对原文件的“大破坏”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成</p>
<p>splice：在任意选择的中点将队列中的两个随机输入拼接在一起.</p>
<p>py&#x2F;custom&#x2F;req：</p>
<p>trim：修建测试用例使其更短，但保证裁剪后仍能达到相同的执行路径</p>
<p>eff</p>
<p>item geometry：</p>
<p>levels: 表示测试等级</p>
<p>pending: 表示还没有经过fuzzing的输入数量</p>
<p>pend fav: 表明fuzzer感兴趣的输入数量</p>
<p>own finds: 表示在fuzzing过程中新找到的，或者是并行测试从另一个实例导入的数量</p>
<p>imported: n&#x2F;a表明不可用，即没有导入</p>
<p>stability: 表明相同输入是否产生了相同的行为，一般结果都是100%</p>
<p>参考博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40025866/article/details/127823491">https://blog.csdn.net/qq_40025866/article/details/127823491</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/25/Exercise%201%20-%20Xpdf/" data-id="clkifzfiq00000wvf0xdk9v6i" data-title="Exercise 1 - Xpdf" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-clash科学上网" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/24/clash%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" class="article-date">
  <time class="dt-published" datetime="2023-07-24T12:54:07.000Z" itemprop="datePublished">2023-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/24/clash%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/">clash科学上网</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>登录clash官方网站</p>
<p><a target="_blank" rel="noopener" href="https://ikuuu.art/">https://ikuuu.art/</a></p>
<p>（网站可能会挂，按照提示访问新域名）</p>
<p>在左侧<strong>下载和教程</strong>中选择<strong>Linux使用教程</strong></p>
<p>1、在用户目录下创建clash文件夹</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir clash</span><br><span class="line">cd clash</span><br></pre></td></tr></table></figure>

<p>2、下载clash二进制文件并解压，重命名为clash，存放在clash目录下</p>
<p>下载链接：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Dreamacro/clash/releases">Releases · Dreamacro&#x2F;clash (github.com)</a></p>
<p>我下载的是<strong>clash-linux-amd64-v3-v1.17.0.gz</strong></p>
<p>改名为clash.gz后解压为clash文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dv clash.gz</span><br></pre></td></tr></table></figure>

<p>3、执行如下命令，下载clash配置文件</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O config.yaml &quot;https://api.sub-200.club/link/k726BxGA2nMeyL8V?clash=3&quot;</span><br></pre></td></tr></table></figure>

<p>4、启动clash，同时启动HTTP代理和Socks5代理，注意先修改权限</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x clash</span><br><span class="line">./clash -d .</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7b3f3f8b-2b2f-4e19-88c4-8652235a1787" alt="image"></p>
<p>5、访问<a target="_blank" rel="noopener" href="https://clash.razord.top/#/proxies">Clash (razord.top)</a>可以切换节点，测试延迟等操作</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/7d6a0bd4-73fe-4f83-b06e-9d47b9e36f26" alt="image"></p>
<p>6、打开系统设置，选择网络，点击网络代理右边的设置按钮，选择手动，修改HTTP和HTTPS代理，如下图所示</p>
<p> <img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/3f10d15b-3067-4930-b328-233400d24af2" alt="image"></p>
<p>可顺利访问外网</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/24/clash%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/" data-id="clkgvhy580000jsvf8zuu2yhx" data-title="clash科学上网" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/learn/" rel="tag">learn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Paper-How to give a good research talk" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/23/Paper-How%20to%20give%20a%20good%20research%20talk/" class="article-date">
  <time class="dt-published" datetime="2023-07-23T05:53:32.000Z" itemprop="datePublished">2023-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/23/Paper-How%20to%20give%20a%20good%20research%20talk/">How to give a good research talk</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="How-to-give-a-good-research-talk（Simon-L-Peyton-Jones）论文细读"><a href="#How-to-give-a-good-research-talk（Simon-L-Peyton-Jones）论文细读" class="headerlink" title="How to give a good research talk（Simon L Peyton Jones）论文细读"></a>How to give a good research talk（Simon L Peyton Jones）论文细读</h3><p><a href="extension://bfdogplmndidlpjfhoijckpakkdjkkil/pdf/viewer.html?file=https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fresearch%2Fwp-content%2Fuploads%2F2016%2F08%2Fgiving-a-talk.pdf">extension:&#x2F;&#x2F;bfdogplmndidlpjfhoijckpakkdjkkil&#x2F;pdf&#x2F;viewer.html?file&#x3D;https%3A%2F%2Fwww.microsoft.com%2Fen-us%2Fresearch%2Fwp-content%2Fuploads%2F2016%2F08%2Fgiving-a-talk.pdf</a></p>
<p>要做一个好的研究演讲，我们需要从论文中找出我们认为有用的东西。</p>
<p>我们演讲的对象大多是研究计算机领域的学者，他们可能不太了解我们所研究的特定领域，我们主要是将我们的经验讲出来，尽力使内容更生动。</p>
<p>在准备演讲的过程中，我们首先要明确两个问题</p>
<ul>
<li>我的主要听众是哪类人</li>
<li>我希望他们记住我演讲中的哪一部分</li>
</ul>
<p>明确了这两个问题后，我们可以以它作为标准来决定我们该详细说什么，省略什么。</p>
<p>大多数人做研究是方式是尝试解决一堆相关的问题，找到一些合适的框架来解决它们，然后对我们的解决方案进行归纳和抽象。比如说，问题是找出一个函数是否对其参数求值，那么合适的框架可能是指称语义，而泛化可能是抽象解释。如果在演讲时只展示框架和抽象，而忽略我们用来指导工作的示例，听众很难理解我们所展示的东西。因此我们在表达观点时，需要用例子来证明我们的观点，当我们给出一个属性的定义，一个数学结构或者是一些新的符号，我们需要举例子说明这个定义包含了什么，距离说明它在实践中的含义。在我们写论文时也要注意细节，正确陈述我们的观点，在准备演讲时要一遍遍问自己有没有用例子来说明这个想法&#x2F;定理&#x2F;定义&#x2F;技术&#x2F;算法。</p>
<p>由于我们的听众中肯定有部分人根本不知道我们分享的领域，因此我们得花一定时间对我们的研究领域进行介绍，但是要避免花太长的时间在介绍研究领域上，否则容易让听众感到厌烦，要直接用一个例子来说明我们要解决的问题，一般用一张PPT列出关于演讲主题的工作，或者对演讲内容进行抽象描述。</p>
<p>在演讲中，我们不能试图隐瞒我们遇到的困难，因为有些观众会发现这些困难，我们可以在演讲中提出这些困难，可能会有观众给我们提出有帮助的建议。</p>
<p>在一张PPT上，人们只能阅读并获取很少的信息，因此一张PPT上有六七个关键点就足够了。在做PPT时，我们要注意PPT不是用来反复强调我们打算说什么，而是应该把我们打算说的东西进行浓缩成关键点，口头进行介绍，而不只是读PPT。</p>
<p>在演讲开始时，要先放一张PPT，给出讲解的大纲，大概讲解一分钟，在演讲进行到三分之一时，要用一张幻灯片说这“这是我到目前为止讨论的内容，现在我将涵盖这些领域”，这样可以帮助我们的听众重新定位，便于他们理解，如果他们有问题可以直接问出来。</p>
<p>我们不要急着做PPT，要先花一两个星期仔细考虑我们要说什么，在演讲的前一天把PPT做好，这样的好处是，当我们在演讲时，PPT的内容在我们脑海中绝对有印象，我们把脑海中的想法讲出来就好。</p>
<p>在演讲前一定要尝试稳定的深呼吸和放松练习，尽量让自己平静下来，如果可以做到和观众进行眼神交流，就这样做，可以提升演讲的效果。</p>
<p>做PPT时我们尽量不要加动画，不同的内容最好放在不同的PPT上，而不是一行行展示要讲的内容。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/23/Paper-How%20to%20give%20a%20good%20research%20talk/" data-id="clrsrunn3000240vfcm2x37k5" data-title="How to give a good research talk" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%BB%86%E8%AF%BB/" rel="tag">论文细读</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Paper-SoK Practical Foundations for Software Spectre Defenses" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/07/14/Paper-SoK%20Practical%20Foundations%20for%20Software%20Spectre%20Defenses/" class="article-date">
  <time class="dt-published" datetime="2023-07-14T11:12:41.000Z" itemprop="datePublished">2023-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/07/14/Paper-SoK%20Practical%20Foundations%20for%20Software%20Spectre%20Defenses/">SoK Practical Foundations for Software Spectre Defenses</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="SoK-Practical-Foundations-for-Software-Spectre-Defenses-论文分享"><a href="#SoK-Practical-Foundations-for-Software-Spectre-Defenses-论文分享" class="headerlink" title="SoK Practical Foundations for Software Spectre Defenses 论文分享"></a>SoK Practical Foundations for Software Spectre Defenses 论文分享</h3><p><a target="_blank" rel="noopener" href="https://www.computer.org/csdl/proceedings-article/sp/2022/131600b517/1FlQz5KjQZ2">https://www.computer.org/csdl/proceedings-article/sp/2022/131600b517/1FlQz5KjQZ2</a></p>
<p>Sok: 软件幽灵防御的实践基础</p>
<p>这篇文章主要是以语义的形式研究幽灵分析的现有基础，讨论语义的不同选择，并描述每种选择的权衡</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>幽灵漏洞</p>
<p>幽灵是最近发现的一系列漏洞，源于现代处理器上的推测执行，幽灵允许攻击者通过导致处理器错误预测控制流，比如说条件跳转或间接调用，或数据流的目标来学习敏感信息。</p>
<p>攻击者可用跨越安全边界窃取机密，比如说由进程抽象提供的硬件边界，由内存安全语言和基于软件的故障隔离技术提供的软件边界。</p>
<p>当处理器意识到自己预测错误时，它会回滚执行，抹去推测对程序员可见的影响，但是在推测执行期间，微架构状态，比如说数据缓存的状态，仍然会被修改，这些变化可能会在推测期间泄露，甚至在回滚之后仍然可以持续，因此攻击者可以从微架构状态中恢复敏感信息，即使这些敏感信息只是随机访问。</p>
<h4 id="幽灵漏洞破解密码"><a href="#幽灵漏洞破解密码" class="headerlink" title="幽灵漏洞破解密码"></a>幽灵漏洞破解密码</h4><p>High-assurance cryptography （高保证密码学）长期依赖于constant_x0002_time programming（常量时间编程），用来创建不受定时侧信道攻击的安全软件。</p>
<p><strong>侧信道攻击</strong>是攻击者利用计算机不经意间释放出的信息信号，比如说电磁辐射，电脑硬件运行产生的声音，来进行破译的攻击模式，例如，黑客可以通过计算机显示屏或硬盘驱动器所产生的电磁辐射，来读取你所显示的画面和磁盘内的文件信息。</p>
<p>常量时间编程确保程序执行不依赖于密码</p>
<p>它是通过三条规则来保证这一点的：</p>
<ul>
<li>控制流（如条件分支）不应该依赖密码</li>
<li>内存访问模式（如进入数组的偏移量）不应该依赖密码</li>
<li>密码不应该被用作可变延迟指令的操作数（如浮点指令或许多处理器上的整数除法的操作数）</li>
</ul>
<p>这些规则确保机密信息在攻击者强大到足以执行缓存攻击、通过分支预测器状态泄露数据或通过端口争用来窥探数据时仍然安全</p>
<p>但是对于幽灵漏洞，常量时间编程不足以保证数据安全</p>
<p>这是一段易受幽灵攻击的代码</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/d5411d41-d51d-4f53-97e6-1a2990b5b412" alt="image"></p>
<p>如果数组arrA只包含公共数据，并且i和arrAlen也是公共数据，那么这段代码符合常数时间编程，但是攻击者可以利用分支错误预测，通过数据缓存泄露得到秘密数据</p>
<p>攻击者首先用适当小的i值重复运行代码，从而使分支预估调节i&lt;arrAlen为真，然后攻击者为i提供一个越界值，处理器判断条件仍为真，并推测地将越界数据加载到x中，随后它将x值作为内存读取操作地址的一部分，再将x的值编码到数据缓存状态中，根据x的值，不同的缓存行将被访问和缓存，一旦处理器发现了预测错误，就会回滚执行，但是数据缓存状态仍然存在，攻击者可以在以后释放数据缓存状态，以便推断x的值</p>
<p>这段代码，攻击者可通过控制流泄露秘密数据</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/f9f2a01e-3ae4-40be-8d25-404ccb43aa52" alt="image"></p>
<p>x作为分支条件的一部分，攻击者可以随机将任意内存读取到x中，然后他们可以通过几种方式泄露x的值，比如说根据各种情况的不同执行时间，通过数据缓存，基于在各种情况下执行的不同内存访问，通过端口竞争，分支预测器状态</p>
<h4 id="使用幽灵打破软件隔离"><a href="#使用幽灵打破软件隔离" class="headerlink" title="使用幽灵打破软件隔离"></a>使用幽灵打破软件隔离</h4><p>幽灵攻击破坏了软件隔离领域的重要保障，在软件隔离领域内，主机应用程序执行不受信任的代码时，确保不受信任的代码无法访问主机的任何数据，但是幽灵攻击可以破坏内存安全和隔离机制</p>
<p>这张图就是一个幽灵攻击破坏软件隔离的例子</p>
<p><img src="https://github.com/dbqyw/qyw.github.io/assets/130265921/45c80e30-26ae-4cba-af07-1852ac17b746" alt="image"></p>
<p>在该代码中，攻击者使用函数guest_func()调用宿主函数get_host_val()从数组中获取值</p>
<p>虽然get_host_val()实现了边界检查，但是攻击者仍然可以通过误操作分支预测其来随机性地访问越界数据，从而破坏隔离保证，一旦攻击者获得了他们选择的越界值，他们可以泄露该值，比如说通过数据缓存。我们需要确保，即使是随机性的，不受信任的代码也不能打破隔离</p>
<h4 id="语义学的选择"><a href="#语义学的选择" class="headerlink" title="语义学的选择"></a>语义学的选择</h4><p>精心设计幽灵分析工具的基础是精心构造的形式化语义，因此语义学的选择是非常重要的</p>
<p>加密代码需要不同的安全属性，因此需要不同的语义和工具</p>
<p>实用语义应该在细节和抽象之间做出适当的权衡：</p>
<ul>
<li>它应该足够详细，以捕捉我们感兴趣的微架构行为</li>
<li>它应该足够抽象，以适用于所有合理的硬件，因为我们不希望我们代码的安全性依赖于特定的缓存替换策略或分支预测器的实现</li>
</ul>
<h5 id="A-泄露模型"><a href="#A-泄露模型" class="headerlink" title="A 泄露模型"></a>A 泄露模型</h5><p>泄露模型指攻击者可以观察到什么信息</p>
<p>任何意图建模侧信道攻击的语义都需要精确定义其攻击者的模型，泄露模型是一个语义攻击者模型的重要部分</p>
<h5 id="B-保密策略"><a href="#B-保密策略" class="headerlink" title="B 保密策略"></a>B 保密策略</h5><p>确定了泄露模型，我们要确定用什么保密策略，即那些值可以泄露，哪些值不能泄露</p>
<p>密码学和隔离等领域已经定义了顺序安全属性的策略</p>
<p>对于密码学，包含秘密数据的内存被认为是敏感的，比如说加密密钥的内存</p>
<p>隔离是声明程序指定的沙盒区域之外的所有内存都不应该被泄露</p>
<p>沙盒是一种安全机制，为运行中的程序提供隔离环境，提供作为一些来源不可信，具有破坏力或无法判定程序意图的程序使用，沙盒可以提供用后即收回的磁盘及内存空间</p>
<h5 id="C-执行模型"><a href="#C-执行模型" class="headerlink" title="C 执行模型"></a>C 执行模型</h5><p>为了推断幽灵攻击，语义必须能够推断推测执行模型中敏感数据的泄露，推测执行模型是推测语义与标准顺序分析的区别，并决定抽象处理器可以执行什么推测，对于开发人员来说，需要权衡选择一个合适的推测执行模型</p>
<ul>
<li>要选择他们模型允许的行为，比如说它们包含哪些微架构预测器，这决定了它们的工具可以捕获哪些幽灵变体</li>
<li>如果可以执行的推测过多，会使它们的分析更加复杂</li>
</ul>
<h5 id="D-非确定性"><a href="#D-非确定性" class="headerlink" title="D 非确定性"></a>D 非确定性</h5><p>推测执行本质上是具有不确定性的，程序中的任何给定的分支都可能正确或错误地进行，而不管实际的条件值，也就是说推测性劫持攻击可以将执行发送到完全不确定的位置</p>
<p>现有的语义都假设攻击者对微架构预测和调度有完全的控制</p>
<p>限制非确定性：</p>
<p>目前已有研究人员实现用编译器完全重构程序，在软件层加强它们自己的限制行为集，将敏感数据分配到单独的内存区域中，并使用页面权限位来禁止不受信任的代码访问这些区域，无论程序如何推测错误，它都读取不了敏感数据</p>
<h5 id="E-高级别的抽象"><a href="#E-高级别的抽象" class="headerlink" title="E 高级别的抽象"></a>E 高级别的抽象</h5><p>幽灵攻击和推测执行从根本上打破了我们对程序应该如何执行的直觉假设，关于程序的高级别的保证不再适用</p>
<p>为了重建更高级别的安全保障，我们首先需要修复我们程序如何执行的模型，从低级语义开始，一旦这些基础牢固地建立了起来，我们才能重建更高级别的抽象</p>
<p>有了足够的基础，我们可以通过修改高级语言的编译器，产生安全的低级程序来恢复高级抽象</p>
<h5 id="F-表现力"><a href="#F-表现力" class="headerlink" title="F 表现力"></a>F 表现力</h5><p>一个好的实用的语义需要有足够强的表达性，我们想要一个能够表达的语义对广泛的可能行为进行建模，比如说幽灵变体</p>
<p>另外，允许太多可能行为的语义会使很多分析变得难以处理</p>
<p>而语义的基本目的是提供硬件的合理抽象或简化，来简化分析，因此语义中包含多少表现力也需要认真权衡</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>推测分析的坚实基础需要对语义和攻击者模型进行适当的选择，开发人员需要考虑较强的泄露模型，那些只通过内存或数据缓存来捕获泄露的泄露模型会导致安全性保证更弱</p>
<p>其次必须考虑所有的幽灵变体，这会增加分析的复杂性，但是开发人员可以将分析与结构化编译技术结合，通过构造来限制或删除幽灵攻击的整个类别</p>
<p>最后，我们建议不要对不必要的架构细节进行建模，比如说对缓存结构或端口争用这种细节进行建模，复杂性更高，并且会降低移植性</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/14/Paper-SoK%20Practical%20Foundations%20for%20Software%20Spectre%20Defenses/" data-id="clrsrunn9000540vfg0dcah40" data-title="SoK Practical Foundations for Software Spectre Defenses" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%BB%86%E8%AF%BB/" rel="tag">论文细读</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fuzzing/" rel="tag">Fuzzing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%AE%89%E5%85%A8/" rel="tag">Web安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/learn/" rel="tag">learn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/" rel="tag">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%BB%86%E8%AF%BB/" rel="tag">论文细读</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CTF/" style="font-size: 17.5px;">CTF</a> <a href="/tags/Fuzzing/" style="font-size: 17.5px;">Fuzzing</a> <a href="/tags/Web%E5%AE%89%E5%85%A8/" style="font-size: 15px;">Web安全</a> <a href="/tags/learn/" style="font-size: 12.5px;">learn</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/%E8%AE%BA%E6%96%87%E7%BB%86%E8%AF%BB/" style="font-size: 20px;">论文细读</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">January 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">August 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/07/">July 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/02/06/Web-File/">Web-File1</a>
          </li>
        
          <li>
            <a href="/2024/02/03/Paper-Code%20Vulnerability%20Detection%20via%20Signal-Aware%20AI/">RESOLVERFUZZ</a>
          </li>
        
          <li>
            <a href="/2024/02/01/Web-SQLi1/">SQLi1</a>
          </li>
        
          <li>
            <a href="/2024/02/01/Web-SQLi2/">SQLi2</a>
          </li>
        
          <li>
            <a href="/2024/01/31/20240131/">20240131</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>